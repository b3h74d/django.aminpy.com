
<html>
<head>

<meta name="google-site-verification" content="_n5bYVtSMu-h5rCV2Uixj98pliCE6YSJpo-Mms3v0kg" />
<title>امنیت در جنگو</title>
<meta name="keywords" content="جنگو, کتاب, امنیت, جعل, django, book, security, cross-site" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="content-language" content="fa" />

<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/statics/stylesheets/djangobook.css"
				type="text/css" />
</head>

<body>
	<div class='main'>
		<div class="top">
			
				<a href="/" class="top">صفحه اصلی</a>
			
			 | 
			
				<a href="/toc.html" class="top">فهرست مطالب</a>
			
			 | 

			
				<a href="/about_book.html" class="top">درباره کتاب</a>
			
			 | 

			
				<a href="http://aminpy.com" class="top">تماس با ما</a>
			
			 | 
			<a href="http://python.aminpy.com" title="جدید">
				پایتون
			</a>
		</div>
		
		
    <div class='phn'>
        <div style="text-align: center; float: left;">
        بعدی
        </div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="float: left; text-align: center"><a href='toc.html'>فهرست مطالب</a></div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="text-align: center">
        
            <a href='/chapter19.html'>قبلی</a>
        
        </div>
    </div>


		<div style="padding-bottom: 20px; padding-top: 10px;">
			<a href="/">
			<h1 style='color: white;'>کتاب جنگو</h1>
		</a></div>

		
		<div class="aval">
			
<h2 >
امنیت در جنگو 
</h2>

<p id="1">
اینترنت می تواند یک مکان ترسناک باشد.
</p>

<p id="2">
این روزها، به نظر می رسد اشتباهات امنیتی خجالت آوری اتفاق می افتند. مشاهده می کنیم که ویروس ها با سرعت شگفت انگیزی گسترش می یابند، بسیاری از کامپیوترهای مورد تهاجم ویروس ها به صورت تسلیحات بکار برده می شوند، تسلیحات بی پایان در برابر فرستندگان spam، و بسیاری، بسیاری از گزارش های دزدی از وب سایت های هک شده مسابقه می دهند.
</p>

<p id="3">
به عنوان توسعه دهندگان وب، ما وظیفه داریم راه هایی را که می توان با این نیروهای تاریکی مبارزه کرد را بیان کنیم. هر توسعه دهنده ی وب نیاز دارد با امنیت به عنوان یک جنبه اساسی از برنامه نویسی وب رفتار کند. متاسفانه، پیاده سازی امنیت سخت است – مهاجمان نیاز است تنها یک آسیب پذیری پیدا کنند، ولی مدافعان باید همه ی این آسیب پذیری ها را محافظت کنند.
</p>

<p id="4">
جنگو تلاش می کند این سختی را سبک تر کند. جنگو جهت محافظت شما به طور خودکار از بسیاری از این اشتباهات امنیتی طراحی شده است که توسعه دهندگان جدید (و حتی با تجربه ها) ایجاد می کنند. ولی همچنان اطلاع کسب کردن از ماهیت این مشکلات، نحوه ی محافظت شما توسط جنگو با اهمیت می باشد، و – از همه مهم تر – مراحلی است که می توان برای امنیت بیشتر کد خود انجام داد.
</p>

<p id="5">
قبل از هر چیز، یک سلب مسئولیت مهم: ما قصد ارائه ی یک راهنمای قطعی برای هر امنیت وب را نداریم، و همچنین تلاشی سعی نداریم هر آسیب پذیری را در یک روش جامع توضیح دهیم. در عوض، یک خلاصه ی کوتاه از مشکلات امنیتی را که در جنگو بکار می روند را ارائه خواهیم کرد.
</p>

<h3 id="6">
موضوع امنیت وب
</h3>

<p id="7">
اگر قرار است تنها یک چیز از این فصل یاد بگیرید، اجازه دهید این باشد:
</p>

<h5 >
هرگز – تحت هیچ شرایطی – به داده های از سمت مرورگر اعتماد نکنید.
</h5>

<p id="8">
هرگز کسی را که آن طرف اتصال HTTP می باشد را نمی شناسید. ممکن است یکی از کاربران شما باشد، ولی به سادگی می تواند یک cracker نابکار بدنبال یک موقعیت باشد.
</p>

<p id="9">
هر داده ای از هر نوعی که از سمت مرورگر می آید، باید با آن به چشم یک داده ی مخرب نگاه کرد. این شامل هر دوی داده های "in band" (مانند، داده های ارسالی از فرم ها وب) و "out of band" (ماند، HTTP header ها، کوکی ها، و اطلاعات دیگر درخواست) می باشند. این ها مسائل جزئی ای درخواست می باشند که مرورگر های معمولا به طور خودکار اضافه می کنند.
</p>

<p id="10">
هر یک از آسیب پذیری های بحث شده در این فصل، به طور مستقیم جلوی اجرای داده ای را که از آن سوی سیم می آید را گرفته و سپس قبل از استفاده از آن، داده ی مورد نظر را بررسی می کنند. باید همواره این سوال را از خودتان بپرسید که "این داده از کجا آمده است؟".
</p>

<h4 id="11">
SQL Injection
</h4>

<p id="12">
SQL injection یک سو استفاده ی رایج می باشد که در آن مهاجم پارامترهای صفحه ی وب (از قبیل داده ی GET/POST یا URL ها) را جهت درج تکه کد های دلخواه SQL که یک برنامه وب ساده به طور مستقیم در پایگاه داده ی خود اجرا می کند را تغییر می دهد. این احتمال دارد خطرناک ترین حالت آسیب پذیری باشد – و متاسفانه، یکی از رایج ترین آن می باشد.
</p>

<p id="13">
این آسیب پذیری، هنگامی که با دست از ورودی کاربر SQL ایجاد می کنید بیشتری احتمال رخ دادن را دارد. برای مثال، تصور کنید، یک تابع جهت جمع آوری یک لیست از اطلاعات تماس، یک صفحه جستجوی تماس می نویسید. جهت جلوگیری از spammer ها از خواندن هر پست الکترونیکی در سیستم، کاربر را مجبور به تایپ نام کاربری کسی قبل از تهیه آدرس الکترونیکی خود می کنیم:
</p>

<pre class="brush: py">
def user_contacts(request):
    user = request.GET['username']
    sql = "SELECT * FROM user_contacts WHERE username = '%s';" % username
    # execute the SQL here...
</pre>


<table class='note'>
    <tr>
        <td valign='top'>
            <img src='/statics/images/note.png' width='40' height='35' />
        </td>
        <td width='95%'><h4>
نکته</h4>
<p id="14">
در این مثال و همه مثال های دیگر که نوشته ایم "این کار را نکن" فقط هدف آموزش بوده است و شما نباید برای پروژه عملی از آن استفاده کنید. این فانکشن ها فقط کار می کنند.
</p>
</td></tr></table>

<p id="15">
هر چند، در ابتدا این خطرناک به نظر نمی آمد، ولی واقعا خطرناک است.
</p>

<p id="16">
ابتدا، تلاش ما در حفاظت از کل لیست پست الکترونیک با یک کوئری به طور هوشمندانه ساخته شده شکست خواهد خورد. فرض کنید، اگر یک مهاجم در box کوئری تایپ کند "' OR 'a'='a" چه اتفاقی می افتد. در این مورد، کوئری که رشته ی مورد نظر درون آن قرار داده شود بدین گونه خواهد بود:
</p>

<pre class="brush: sql">
SELECT * FROM user_contacts WHERE username = '' OR 'a' = 'a';
</pre>

<p id="17">
به این دلیل که به SQL نا امن را درون رشته اجازه دادیم، عبارت OR مهاجم مطمئن است که هر ردیف تنها برگردانده شده است.
</p>

<p id="18">
هر چند، که حداقل حمله ترسناک می باشد. تصور کنید، اگر مهاجم عبارتی شبیه به این را ارسال کنید چه اتفاقی خواهد افتاد "'; DELETE FROM user_contacts WHERE 'a' = 'a". کوئری کامل چیزی شبیه به این خواهد بود:
</p>

<pre class="brush: sql">
SELECT * FROM user_contacts WHERE username = ''; DELETE FROM user_contacts WHERE 'a' = 'a';
</pre>

<p id="19">
اوه! تمام لیست تمام به سرعت حذف می شود.
</p>

<h4 id="20">
راهکار
</h4>

<p id="21">
اگرچه این مشکل موذیانه و گاهی اوقات کشف آن سخت می باشد، راهکار آن ساده می باشد: هرکز به داده ی ارسال شده از سمت کاربر اعتماد نکنید، و همواره از ارسال آن به SQL اجتناب کنید. 
</p>

<p id="22">
API پایگاه داده ی جنگو این کار را برای شما انجام می دهد. این API به طور خودکار تمام پارامترهای ویژه ی SQL را رد می کند، با توجه به قراردادهای به نقل از سرور پایگاه داده ای که از آن استفاده می کنید (مانند PostgreSQL یا MySQL).
</p>

<p id="23">
برای مثال، در این فراخوانی API:
</p>

<pre class="brush: py">
foo.get_list(bar__exact="' OR 1=1")
</pre>

<p id="24">
جنگو بر این اساس از ورودی را رد می کند، نتیجه چیزی شبیه به این خواهد بود:
</p>

<pre class="brush: sql">
SELECT * FROM foos WHERE bar = '\' OR 1=1'
</pre>

<p id="25">
کاملا بی ضرر.
</p>

<p id="26">
این در تمام API پایگاه داده ی جنگو بکار برده می شود، با تعدادی استثنا:
</p>

<ul >
<li id="27">
آرگومان where به متد extra(). (Appendix C را مشاهده کنید.) آن پارامتر SQL خام را توسط design قبول می کند.
</li>
<li id="28">
کوئری های زده شده "به صورت دستی" با استفاده از API پایگاه داده ی سطح پایین تر. (فصل دهم را مشاهده کنید.)
</li>
</ul>

<p id="29">
در هر یک از این موارد، محافظت از خودتان ساده می باشد. در هر مورد، از رشته ی interpolation دوری کنید وقتی می توانید از ارسال پارامترهای bind استفاده کنید. مثالی که در این بخش شروع کردیم باید به صورت زیر باشد:
</p>

<pre class="brush: py">
from django.db import connection

def user_contacts(request):
    user = request.GET['username']
    sql = "SELECT * FROM user_contacts WHERE username = %s"
    cursor = connection.cursor()
    cursor.execute(sql, [user])
    # ... do something with the results
</pre>

<p id="30">
متد سطح پایین execute یک رشته ی SQL با placeholder یعنی %s دریافت می کند و به طور خودکار پارامترهایی را که از لیست ارسال شده به صورت آرگومان دوم را رد و درج می کند. می توان همواره با این روش SQL سفارشی ساخت.
</p>

<p id="31">
متاسفانه، نمی توان از پارامترهای bind در هر جایی از SQL استفاده کرد؛ آن ها به صورت identifier ها مجاز نمی باشند (مانند، جدول یا نام های ستون). در نتیجه، در صورت نیاز، تصور کنید، به صورت پویا یک لیست از جداول از یک متغیر POST ساخته شده است، نیاز خواهید داشت آن نام را در کد کد escape کنید. جنگو یک تابع با نام django.db.connection.ops.quote_name ارائه می دهد، که identifier را بر طبق الگوی quoting پایگاه داده ی فعلی escape می کند. 
</p>


<h3 id="32">
Cross-Site (XSS) اسکریپت نویسی
</h3>

<p id="33">
اسکریپت نویسی cross-site (XSS)، کشف شده در برنامه های وب می باشد که جهت escape کردن محتوای ارسالی کاربر قبل از render کردن آن درون HTML می باشد. این موضوع به مهاجم اجازه می دهد HTML دلخواه خود را درون صفحه ی وب شما درج کند، معمولا در شکل تگ های &lt;script&gt;.
</p>

<p id="34">
مهاجمان اغلب از حملات XSS جهت دزدیدن اطلاعات session و کوکی استفاده می کنند، یا جهت فریب کاربران در دادن اطلاعات شخصی به یک شخص غلط (که نام دیگر آن phishing می باشد).
</p>

<p id="35">
این نوع حمله می تواند یک تعداد از فرم های مختلف دریافت کرده و اغلب دارای تغییر اساسی نامحدود می باشد، بنابراین تنها یک مثال نمونه را بررسی نگاه می کنیم. به view بی نهایت ساده ی "Hello, World" ملاحظه کنید:
</p>

<pre class="brush: py">
from django.http import HttpResponse

def say_hello(request):
    name = request.GET.get('name', 'world')
    return HttpResponse('&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name)
</pre>

<p id="36">
این view به سادگی نام پارامتر GET را خوانده و آن نام را به HTML تولید شده ارسال می کند. بنابراین، در صورتی که به http://example.com/hello/?name=Jacob دسترسی پیدا کنیم، صفحه حاوی کد زیر خواهد بود:
</p>

<pre class="brush: py">
&lt;h1&gt;Hello, Jacob!&lt;/h1&gt;
</pre>

<p id="37">
اما صبر کنید – چه اتفاقی می افتد اگر به http://example.com/hello/?name=&lt;i&gt;Jacob&lt;/i&gt; دسترسی پیدا کنید؟ در اینصورت کد زیر اتفاق می افتد:
</p>

<pre class="brush: html">
&lt;h1&gt;Hello, &lt;i&gt;Jacob&lt;/i&gt;!&lt;/h1&gt;
</pre>

<p id="38">
البته، یک مهاجم از چیز ابتدایی مانند تگ های &lt;i&gt; استفاده نمی کند؛ وی یک مجموعه ی کامل از HTML که صفحه ی شما را به محتوای دلخواه سرقت کند در آنجا قرار می دهد. این نوع حمله جهت فریب دادن کاربر برای وارد کردن داده به وب سایت هایی مانند بانک و غیره استفاده می شود، ولی در واقع یک XSS-hijacked، اطلاعات برگشتی حساب را به یک مهاجم ارسال می کند.
</p>

<p id="39">
مشکل وخیم تر می شود اگر این داده را درون پایگاه داده ذخیره کنید و بعد آن را درون سایت خود نمایش دهید. برای مثال، MySpace یک بار برای یک حمله ی XSS از این نوع آسیب پذیر بوده است. یک کاربری که جاوا اسکریپت درون پروفایل شما درج کرده است که به طور خودکار او را به صورت دوست شما اضافه می کند زمانی که صفحه پروفایل او را بازدید می کنید. در عرض چند روز، او میلیون ها دوست خواهد داشت.
</p>

<p id="40">
حالا، این ممکن است نسبتا ملایم باشد، ولی به خاطر داشته باشید که این مهاجمان برای بدست آوردن کد خود مدیریت می کنند – نه MySpace – اجرا کردن در کامپیوتر شما. این تجاوزات مورد اعتماد فرض شده اند که تمام کد در MySpace واقعا توسط MySpace نوشته شده است.
</p>

<p id="41">
MySpace به شدت شانس آورد که این مخربان کد به طور خودکار حساب های کاربران را حذف، رمز عبور آن ها را تغییر، سایت را با spam غرق، یا هر سناریو خوفناک دیگری که احتمال داشت را انجام ندادند.
</p>

<h3 id="42">
راهکار
</h3>

<p id="43">
راهکار ساده است: همواره از هر محتوایی را که ممکن است از سمت یک کاربر قبل از درج آن درون HTML باشد دوری کنید.
</p>

<p id="44">
جهت محافظت در برابر این، سیستم template جنگو به طور خودکار تمام مقادیر متغیر را escape می کند. اجازه دهید ببینیم چه اتفاقی می افتد اگر مثال خودمان را با استفاده از سیستم template بنویسیم:
</p>

<pre class="brush: py">
# views.py

from django.shortcuts import render_to_response

def say_hello(request):
    name = request.GET.get('name', 'world')
    return render_to_response('hello.html', &#123;'name': name&#125;)

# hello.html

&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt;
</pre>



<p id="45">
با استفاده از این سیستم، یک درخواست به http://example.com/hello/name=&lt;i&gt;Jacob&lt;/i&gt; نتیجه اش کد زیر خواهد بود:
</p>

<pre class="brush: html">
&lt;h1&gt;Hello, &amp;lt;i&amp;gt;Jacob&amp;lt;/i&amp;gt;!&lt;/h1&gt;
</pre>

<p id="46">
auto-escaping جنگو در فصل چهارم مورد پوشش قرار داده شده است، همراه با راه های خاموش کردن آن. ولی حتی اگر از این خصوصیت استفاده کنید، باید همچنان این عادت را داشته باشید که همواره از خود سوال را کنید "این داده از کجا آمده است؟" هیچ راهکار خودکاری هرگز سایت شما را از حملات XSS به طور 100% حفاظت نمی کند.
</p>

<h3 id="47">
درخواست ساختگی Cross-Site
</h3>

<p id="48">
درخواست ساختگی cross-site (cross-site request forgery، CSRF)، هنگامی که یک مخرب کاربران را در بارگذاری ندانسته یک URL از یک سایت که آنها قبلا در آن authenticate شدن اتفاق می افتد – از این رو از وضعیت authenticate شده آن ها سود می برند.
</p>

<p id="49">
جنگو دارای ابزار داخلی برای محافظت از این قبلی حملات می باشد. هر دوی خود حمله و ابزار مقابله با آن به تفصیل در فصل شانزدهم توضیح داده شده است.
</p>

<h3 id="50">
ربودن/جعل کردن Session
</h3>

<p id="51">
این یک حمله ی خاص نیست، بلکه یک کلاس عمومی از حملات در یک داده session کاربر می باشد. می تواند به شکل های مختلف باشد:
</p>

<ul >
<li id="52">
حمله ی man-in-the-middle، جایی که یک مهاجم در داده session به صورت پیمودن در سرتاسر شبکه ی سیمی (یا بی سیم) تجسس می کند.
</li>

<li id="53">
session forging، جایی که یک مهاجم از یک session ID (که ممکن است از طریق یک حمله ی man-in-the-middle به دست آورده باشد) برای وانمود کردن این که کاربر دیگری می باشد استفاده می کند.
</li>

یک مثال از این دوتای اول، یک مهاجم می باشد که در یک کافی شاپ، از شبکه ی بی سیم برای گرفتن یک کوکی session استفاده می کند. وی سپس می تواند از آن کوکی جهت جعل هویت خود به عنوان یک کاربر اصلی استفاده کند.

<li id="54">
حمله ی cookie-forging، جایی که یک مهاجم داده ی به ظاهر read-only ذخیره شده در یک کوکی را override می کند. فصل چهاردهم نحوه ی عملکرد کوکی را به تفصیل توضیح داده است، و یکی از نکات برجسته، تغییر کوکی به سادگی و بدون اطلاع شما توسط کاربران مخرب می باشد.
</li>

یک تاریخچه ی طولانی از وب سایت هایی که دارای یک کوکی ذخیره شده مانند IsLoggedIn=1 یا حتی LoggedInAsUser=Jacob بوده اند وجود دارد. سو استفاده از این نوع کوکی های بسیار ساده می باشد.
&lt;br&gt;
در سطح زیرکانه تر، اگر چه، اعتماد کردن از هر آنچه که درون کوکی ها ذخیره می شود هرگز ایده ی خوبی نیست، شما هرگز کسی را که با آن ها سر و کار دارد را نمی شناسید.

<li id="55">
session fixation، هنگامی که یک مهاجم یک کاربر را در تنظیمات یا دوباره قرار دادن session ID فریب می دهد.
</li>

    برای مثال، PHP به identifier های session اجازه می دهد درون URL ارسال شوند (مانند، http://example.com/?PHPSESSID=fa90197ca25f6ab40bb1374c510d7a3). یک مهاجم کسی که یک کاربر را فریب می دهد تا بر روی یک لینک با یک session ID به طور مستقیم قرار داده شده کلیک کند که موجب خواهد شد کاربر آن session را دوباره قرار دهد.
&lt;br&gt;
    session fixation در حملات phishing جهت فریب کاربران برای وارد کردن اطلاعات شخصی درو یک حساب که متعلق به یک مهاجم است استفاده می شود. او می تواند بعدا درون آن حساب وارد شده و داده را بازیابی کند.

<li id="56">
session poisoning، جایی که یک مهاجم به طور بالقوه داده خطرناک را بدون session کاربر تزریق می کند – معمولا از طریق یک وب که کاربر برای قرار دادن session اطلاعات را ارسال می کند.
</li>

یک مثال استاندارد یک سایت می باشد که یک preference ساده ی کاربر (مانند یک رنگ زمینه ی صفحه) را در یک کوکی ذخیره می کند. یک مهاجم می تواند یک کاربر را برای کلیک بر روی یک لینک که یک "color" را ارسال می کند فریب دهد که واقعا حاوی یک حمله ی XSS می باشد. در صورتی که رنگ escape نشده باشد، کاربر می تواند دوباره کد مخرب خود را درون محیط کاربر تزریق کند.
</ul>

<h4 id="57">
راهکار
</h4>

<p id="58">
تعدادی اصول کلی وجود دارد که می تواند شما را از این حملات محافظت کنند:
</p>

<ul >
<li id="59">
هرگز اجازه ندهید اطلاعات session در URL قرار بگیرند.
</li>

فریم ورک session جنگو (فصل چهاردهم را مشاهده کنید) به سادگی اجازه نمی دهد که session های درون URL قرار بگیرند.
<li id="60">
داده را به طور مستقیم درون کوکی ذخیره نکنید، در عوض یک session ID را که به داده session ذخیره شده در backend مرتبط است را ذخیره کنید.
</li>

در صورتی که از فریم ورک داخلی session (مانند، request.session) استفاده می کنید، این به طور خودکار برای شما کنترل شده است. تنها کوکی ای که فریم ورک session استفاده می کند یک session ID تک می باشد؛ تمام داده ی session درون پایگاه داده ذخیره شده است.

<li id="61">
فراموش نکنید، در صورتی که داده ی session را در template نمایش می دهید آن را escape کنید. بخش XSS قبلی را مشاهده کرده، و به یاد داشته باشید که هر محتوای ساخته شده توسط کاربر را به همان خوبی داده های آمده از سمت مرورگر بکار می برد. می توان با اطلاعات session به مانند اطلاعات ساخته شده توسط کاربر رفتار کرد.
</li>

<li id="62">
جلوی مهاجمان را از فریب دادن session ID ها هر زمان که ممکن است بگیرید.
</li>

اگرچه تقریبا شناسانی کسانی که یک session ID را سرقت می کنند ممکن است، جنگو دارای محافظت های داخلی در برابر یک حمله بی رحم session می باشد. session ID ها به صورت hashe ها ذخیره می شوند (به جای اعداد ترتیبی)، که یک حمله ی بی رحمانه را منع می کنند، و یک کاربر همواره در صورتی که برای یکی که وجود ندارد تلاش کند، یک session ID جدید دریافت خواهد کرد، که از session fixation جلوگیری می کند.
</ul>

<p id="63">
توجه کنید که هیچ از آن اصول و ابزارها حملات man-in-the-middle را جلوگیری نمی کنند. شناسایی این نوع از حملات تقریبا غیر ممکن است. در صورتی که سایت شما اجازه می دهد کاربران برای مشاهده ی هر گونه از داده های حساس وارد شوند، باید همواره آن سایت درون HTTPS خدمات دهد. علاوه بر این، در صورتی که دارای یک سایت SSL-enabled هستید، باید تنظیم SESSION_COOKIE_SECURE را مقدار True قرار دهید؛ این باعث می شود جنگو کوکی های session را از درون HTTPS ارسال کند.
</p>

<h4 id="64">
E-mail Header Injection
</h4>

<p id="65">
SQL injection نسبت به برادر خود e-mail header injection کم تر معروف است، که فرم های وب ارسال شده در پست الکترونیکی را سرقت می کند. یک مهاجم می تواند از این تکنیک برای ارسال spam از طریق mail سرور ما استفاده کند. هر فرمی که هدرهای ایمیل را از داده فرم وب می سازد برای این نوع حمله آسیب پذیر می باشد.
</p>

<p id="66">
اجازه دهید نگاهی به تماس canonical که در بسیاری از سایت ها پیدا شده است بیاندازیم. معمولا این یک پیام به صورت کد مستقیم به یک آدرس ایمیل ارسال می کند و از این رو، در نگاه اول برای سو استفاده ی spam آسیب پذیر ظاهر نمی شود.
</p>

<p id="67">
هرچند، اغلب این فرم ها همچنین به کاربر برای تایپ در subject خودش برای ایمیل اجازه می دهند (به همراه یک آدرس "from"، بدنه، و گاهی اوقات فیلدهای دیگر). این فیلد subject برای ساخت هدر "subject" از پیام ایمیل استفاده می شوند.
</p>

<p id="68">
در صورتی که آن هدر هنگام ساختن پیام ایمیل escape نشده باشد، یک مهاجم می تواند چیزی مانند "hello\ncc:spamvictim@example.com" ارسال کند (جایی که "\n" یک کارکتر خط جدید می باشد). آن ایمیل ساخته شده را به شکل زیر تغیری می دهد:
</p>

<pre class="brush: html">
To: hardcoded@example.com
Subject: hello
cc: spamvictim@example.com
</pre>

<p id="69">
همانند SQL injection، در صورتی که به خط subject داده شده توسط کاربر اعتماد کنیم، اجازه خواهیم داد به او که یک مجموعه از هدرهای مخرب را بسازد، و او می تواند از contact خود برای ارسال spam استفاده کند.
</p>

<h4 id="70">
راهکار
</h4>

<p id="71">
می توان با روش همسانی که برای جلوگیری از SQL injection استفاده می کردیم برای جلوگیری از این حمله استفاده کرد: همواره محتوای ارسال شده توسط کاربر را escape یا validate کنید.
</p>

<p id="72">
توابع mail داخلی جنگو (در django.core.mail) به سادگی به خط های جدید در هر فیلد اجازه نمی دهد برای ساختن هدر استفاده شوند (from و address، به اضافه ی subject). در صورتی که سعی به استفاده از django.core.mail.send_mail با یک subject دارید که حاوی خط های جدید می باشد، جنگو یک خطای BadHeaderError ایجاد می کند.
</p>

<p id="73">
در صورتی که از توابع داخلی mail جهت ارسال ایمیل استفاده نمی کند، نیاز خواهید داشت، اطمینان حاصل کنید که خط های جدید در هدرها موجب بروز خطا شده یا حذف شوند. ممکن است بخواهید کلاس SafeMIMETest را در django.core.mail برای مشاهده ی انجام این عمل توسط جنگو را بررسی کنید.
</p>

<h3 id="74">
پیمایش دایرکتوری
</h3>

<p id="75">
پیمایش دایرکتوری یکی دیگر از حملات به شکل injection می باشد، جایی که یک کاربر مخرب کد filesystem را برای خواند و/یا نوشتن فایل هایی که وب سرور نباید به آن ها دسترسی داشته باشد فریب می دهند.
</p>

<p id="76">
یک مثال ممکن یک view باشد که فایل ها را بدون دقت نام آن فایل می خواند:
</p>

<pre class="brush: py">
def dump_file(request):
    filename = request.GET["filename"]
    filename = os.path.join(BASE_PATH, filename)
    content = open(filename).read()

    # ...
</pre>

<p id="77">
هر چند به نظر می رسد که view دسترسی فایل را به فایل های زیر BASE_PATH (توسط استفاده از os.path.join) محدود کرده است، در صورتی که مهاجم در یک filename محتویات .. (مختصر نویسی دایکرتوری پدر) را ارسال کند، می تواند به فایل های بالای BASE_PATH دسترسی پیدا کند. در دست ترجمه ....
</p>

<p id="78">
هر چیزی که فایل ها را بدون escape مناسب بخواند برای این مشکل آسیب پذیر است. view هایی که فایل ها را به این شکل آسیب پذیر می نویسند، دارای عواقب دو چندان وخیم می باشند.
</p>

<p id="79">
تغییر دیگر از این مشکل در کدی قرار دارد که به طور پویا مازول های بر اساس URL یا اطلاعات درخواست دیگر را بارگذاری می کند. یک مثال شایع در مورد دنیای Ruby on Rails می باشد. قبل از اواسط سال 2006، Rails از URL های شبیه به http://example.com/person/poke/1 به طور مستقیم برای بارگذاری ماژول های و فراخوانی متدها استفاده می کرد. نتیجه آن بود که یک URL به دقت ساخته شده می توانست به طور خودکار کد دلخواه را بارگذاری کنید، شامل یک اسکریپت دوباره راه اندازی کننده ی دیتابیس!
</p>

<h4 id="80">
راهکار
</h4>

<p id="81">
در صورتی که کد شما هموراه نیاز به خواندن یا نوشتن فایل ها بر اساس ورودی کاربر دارد، نیاز به تمیز کردن مسیر درخواست شده به طور بسیار با دقت جهت اطمینان از این که یک مهاجم قادر به escape از دایرکتوری پایه ای که شما دسترسی به آن را محدود کرده اید دارید.
</p>


<table class='note'>
    <tr>
        <td valign='top'>
            <img src='/statics/images/note.png' width='40' height='35' />
        </td>
        <td width='95%'><h4>
نکته</h4>
<p id="82">
نیازی به گفتن نیست، که شما هرگز نباید کدی بنویسید که بتواند از هر منطقه ای از دیسک بخواند!
</p>
</td></tr></table>

<p id="83">
یک مثال خوب از نحوه ی انجام این escape در محتوی ارائه شده ی استاتیک view می باشد (در django.views.static). در اینجا کد مرتبط وجود دارد:
</p>

<pre class="brush: py">
import os
import posixpath

# ...

path = posixpath.normpath(urllib.unquote(path))
newpath = ''
for part in path.split('/'):
    if not part:
        # strip empty path components
        continue

    drive, part = os.path.splitdrive(part)
    head, part = os.path.split(part)
    if part in (os.curdir, os.pardir):
        # strip '.' and '..' in path
        continue

    newpath = os.path.join(newpath, part).replace('\\', '/')
</pre>

<p id="84">
جنگو فایل ها را نمی خواند (مگر این که از تابع static.serve استفاده کنید، ولی آن با کدی که نشان داده شد محافظت شده است)، بنابراین این آسیب پذیری بر هسته ی کد ندارد.
</p>

<p id="85">
علاوه بر این، استفاده از URLconf abstraction بدین معناست که جنگو هرگز کدی را که به طور واضح نگفته اید بارگذاری شود بارگذاری نمی کند. هیچ راهی برای ساختن یک URL ای که موجب می شود جنگو چیزی را که در یک URLconf ذکر نشده است را بارگذاری کند وجود ندارد.
</p>

<h3 id="86">
پیام های خطای محافظت نشده
</h3>

<p id="87">
در طول توسعه، قادر بودن برای مشاهده ی traceback ها و خطا هایی که در مرورگر شما وجود دارند به شدت مفید می باشد. جنگو دارای پیام های debug خوب و آموزنده ای جهت debug کردن آسان تر می باشد.
</p>

<p id="88">
البته در صورتی که، این خطا ها یک بار در سایتی نمایش داده شود، می تواند جنبه هایی از کد شما یا پیکربندی را فاش کند که می تواند به یک مهاجم کمک کند.
</p>

<p id="89">
بعلاوه، خطا ها و traceback ها همیشه برای کاربران مفید نمی باشد. فلسفه ی جنگو این است که بازدید کنندگان سایت نباید هرگز پیام های خطای مرتبط به برنامه را مشاهده کنند. در صورتی که کد شما یک خطای handle نشده را ایجاد کند، یک بازدید کننده ی سایت نباید traceback کامل را مشاهده کند – یا هر اشاره ای از تکه های کد یا پیام های خطای پایتون. در عوض، بازدید کننده باید یک پیام دوستانه "این صفحه قابل دسترسی نمی باشد" دریافت کند.
</p>

<p id="90">
البته به طور طبیعی، توسعه دهندگان نیاز دارند traceback ها برای debug برنامه ها در کد آن ها مشاهده کنند. بنابراین فریم ورک باید تمام پیام های خطا را برای عموم مخفی کند، ولی باید آن ها را برای توسعه دهندگان مورد اعتماد سایت نمایش دهد.
</p>

<h4 id="91">
راهکار
</h4>

<p id="92">
همانطور که در فصل دوازدهم پوشش داده شده است، تنظیم DEBUG جنگو نمایش این پیام های خطا را کنترل می کند. اطمینان حاصل کنید که این تنظیم زمانی که برای deploy آماده می باشید False است.
</p>

<p id="93">
کاربرانی که می خواهند deploy را در Apache و mod_python (همچنین فصل دوازدهم را مشاهده کنید) انجام دهند، همچنین باید اطمینان حاصل کنند که دارای PythonDebug Off در فایل های conf آپاچی می باشند؛ این موضوع هر خطایی که قبل از آنکه جنگو دارای یک شانس برای بارگذاری باشد را سرکوب خواهد کرد.
</p>

<h3 id="94">
حرف آخر درباره ی امنیت
</h3>

<p id="95">
ما امیدواریم تمام این صحبت های درباره ی مشکلات امنیتی رعب آور نبوده باشد. درست است که وب می تواند یک دنیای وحشی باشد، ولی با کمی دور اندیشی، می توانید یک وب سایت امن داشته باشید.
</p>

<p id="96">
به خاطر داشته باشید که امنیت وب یک تغییر فیلد به طور دائم است: در صورتی که در حال خواندن نسخه ی dead-tree این کتاب می باشید، مطمئن شوید که بررسی های به روز تری از منابع امنیتی برای هر آسیب پذیری جدید که کشف شده است انجام داده اید. در واقع، همواره ایده ی خوبی است که مدت زمانی را در هفته یا ماه برای جستجو و تحقیق در مورد امنیت برنامه ی وب کنار بگذارید. این یک سرمایه گذاری کوچک است، ولی حفاظتی که برای سایت خود و کاربرانتان بدست می آورید بدون خرج خواهد بود.
</p>

<h3 id="97">
گام بعدی
</h3>

<p id="98">
شما به پایان برنامه ی برنامه ریزی شده ی منظم خود رسیده اید.
</p>

<p id="99">
آرزوی بهترین موفقیت ها را در اجرای سایت جنگویی که خواهید ساخت برای  شما می کنیم، خواه این سایت یک اسباب بازی کوچک برای شما و دوستانتان باشد یا یک گوگل دیگر.
</p>


		</div>
		

			<div class="footer">
This work is licensed under the GNU Free Document License
                                <br />
                                Copyright © 2011 - <a href="http://aminpy.com/" target="_blank">Amin Oruji</a>
				
    <div class='phn1'>
        <div style="text-align: center; float: left;">
        بعدی
        </div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="float: left; text-align: center"><a href='toc.html'>فهرست مطالب</a></div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="text-align: center">
        
            <a href='/chapter19.html'>قبلی</a>
        
        </div>
    </div>

			</div>
</div>
</body>
</html>

