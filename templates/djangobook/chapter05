[h2][h2/]
فصل پنجم: مدل ها در جنگو 
[/h2]

[p]id="1"[p/]
در فصل سوم، اصول ساختن وب سایت های پویا در جنگو شرح داده شد به عبارت دیگر اصول راه اندازی view ها و URLconf ها را بررسی کردیم. همانطور که توضیح داده شد، view مسئولیت انجام برخی منطق های اختیاری و برگرداندن یک پاسخ را به عهده دارد. در یکی از مثال ها، منطق اختیاری، محاسبه کردن زمان و تاریخ فعلی بود.
[/p]

[p]id="2"[p/]
در برنامه های وب پیشرفته، منطق اختیاری اغلب درگیر تعامل با یک پایگاه داده می باشد. در پشت صحنه، یک وب سایت پایگاه داده محور، وب سایت به یک سرور پایگاه داده متصل می شود، برخی داده ها را از درون آن بازیابی می کند و آن داده ها را درون یک صفحه ی وب نمایش می دهد. یک سایت همچنین ممکن است روش هایی برای بازدیدکنندگان سایت تهیه کند تا بتوانند محتویات پایگاه داده را برای خودشان افزایش دهند.
[/p]

[p]id="3"[p/]
بسیاری از وب سایت های پیچیده یک سری ترکیب از دو موضوع را تهیه می کنند. به عنوان نمونه Amazon.com، یک مثال عالی برای یک سایت پایگاه داده محور می باشد. هر صفحه ی محصول اساسا یک پرس وجو (Query) قالب بندی شده به صورت HTML، درون پایگاه داده ی محصول آمازون می باشد و هنگامی که شما یک بررسی مشتری را ارسال می کنید، آن بررسی ها درون پایگاه داده درج می شوند.
[/p]

[p]id="4"[p/]
جنگو برای ساختن وب سایت های پایگاه داده محور مناسب می باشد، زیرا جنگو با استفاده از پایتون ابزار قدرتمندی را برای اجرای پرس و جوهای پایگاه داده ایجاد کرده است. در این فصل به عملکرد لایه ی پایگاه داده ی جنگو پرداخته می شود.
[/p]

[p]id="5"[p/]
(نکته: بهتر است با تئوری های پایگاه داده ی relational و SQL تاحدودی آشنا باشید. آشنا سازی برای این مفاهیم خارج از حوصله ی این کتاب می باشد، ولی حتی اگر شما یک کاربر جدید پایگاه داده می باشید باز هم این کتاب را بخوانید. ممکن است بتوانید مفاهیم و اصول اولیه پایگاه داده را درک کنید.)
[/p]

[h3]id="6"[h3/]
روش اولیه ی اجرای پرس و جوهای پایگاه داده در view ها
[/h3]

[p]id="7"[p/]
همانطور که در فصل سوم توضیح داده شد، روش اولیه ی برای تولید خروجی درون یک view (از طریق نوشتن کد به طور مستقیم درون view) برای بازیابی داده از یک پایگاه داده درون یک view می باشد. این روش ساده می باشد زیرا فقط نیاز به استفاده از کتابخانه ی پایتون برای اجرای یک پرس و جوی SQL و کار با نتایج بدست آمده می باشد.
[/p]

[p]id="8"[p/]
در مثال view زیر، از کتابخانه ی MySQLdb (قابل دسترس از طریق آدرس [چپ]http://wwww.djangoproject.com/r/python-mysql/[/چپ]) استفاده شده است. برای اتصال به پایگاه داده MySQL، بازیابی برخی رکوردها و پر کردن آن برای یک template جهت نمایش به صورت یک صفحه ی وب:
[/p]

[code]
from django.shortcuts import render_to_response
import MySQLdb

def book_list(request):
    db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
    cursor = db.cursor()
    cursor.execute('SELECT name FROM books ORDER BY name')
    names = [row[0] for row in cursor.fetchall()]
    db.close()
    return render_to_response('book_list.html', {'names': names})
[/code]

[p]id="9"[p/]
روش فوق می تواند جوابگوی نیاز ما باشد، اما معایبی دارد که در ادامه به آنها اشاره شده است:
[/p]

[ul][ul/]
[li]id="10"[li/]
پارامترهای connection پایگاه داده به صورت مستقیم درون کد قرار گرفته اند. ایده آل آن است که، این پارامترها درون پیکربندی جنگو ذخیره شوند.
[/li]

[li]id="11"[li/]
تعداد زیادی کد تکراری مانند ساختن connection، ساختن cursor، اجرا کردن جملات و بستن connection در مثال فوق وجود دارد. برای بهره وری مناسب تر ایده آل آن است که تنها نیازمند تعیین نتایج مورد نیاز برنامه باشیم.
[/li]

[li]id="12"[li/]
روش فوق برنامه نویس را به MySQL گره می زند. در صورتیکه برنامه نویس بخواهد پایگاه داده ی خود را تغییر دهد، به عنوان مثال، اگر بخواهد بجای MySQL از PostgreSQL استفاده کند، می بایست از یک adapter پایگاه داده ی متفاوت (psycopg به جای MySQLdb)، پارامتر های connection دیگر و همچنین بسته به ذات پایگاه داده، از جملات SQL متفاوت دیگر استفاده کرد. ولی همانطور که قبلا هم اشاره کردیم ایده آل آن است که، در صورت تغییر پایگاه داده، برنامه نویس دیگر نگران تغییر جملات و ... نباشد.
[/li]
[/ul]

[p]id="13"[p/]
همانطور که انتظار داریم، لایه ی پایگاه داده ی جنگو راه حلی برای حل این مشکلات ارائه کرده است. مثال زیر کد بازنویسی شده ی قبلی را با استفاده از API پایگاه داده ی جنگو  نشان می دهد:
[/p]

[code]
from django.shortcuts import render_to_response
from mysite.books.models import Book

def book_list(request):
    books = Book.objects.order_by('name')
    return render_to_response('book_list.html', {'books': books})
[/code]

[p]id="14"[p/]
کد فوق کمی بعد در همین فصل شرح داده خواهد شد. تنها برای حالا کافی است دید کلی نسبت به این API پیدا کنید.
[/p]

[h3]id="15"[h3/]
الگوی توسعه ی MTV (یا MVC)
[/h3]

[p]id="16"[p/]
تاکنون در این کتاب، همواره به درون کد تمرکز شده است، اجازه دهید برای لحظاتی به بررسی یک برنامه ی وب پایگاه داده محور جنگو بپردازیم.
[/p]

[p]id="17"[p/]
همانطور که در فصل گذشته بیان شد، جنگو به نحوی طراحی شده است که برنامه نویس را تشویق کند تا اصول loose coupling و جداسازی بین قسمت های یک برنامه را رعایت کند. در صورتیکه این فلسفه را دنبال کنید، ایجاد تغییرات در یک قسمت مشخص از برنامه هیچ تاثیری بر روی قسمت های دیگر برنامه نخواهد داشت. برای نمونه در توابع view، اهمیت جداسازی منطق برنامه از قسمت ظاهر برنامه با استفاده از template توضیح داده شد. در لایه ی پایگاه داده، همین فلسفه را برای دسترسی به داده بکار خواهیم برد.
[/p]

[p]id="18"[p/]
این سه قسمت با یکدیگر (دسترسی به داده، منطق برنامه و ظاهر برنامه) یک مفهومی را در بر دارد که الگوی Model-View-Controller (MVC) از معماری نرم افزار نامیده می شود. در این الگو، Model به لایه ی دسترسی داده اشاره می کند، View به بخشی از سیستم که به انتخاب آنچه را که باید نمایش دهد و اینکه چطور باید آن را نمایش دهد اشاره می کند و Controller به بخشی از سیستم که بسته به ورودی کاربر تصمیم می گیرد کدام view باید استفاده شود اشاره دارد.
[/p]

[note]چرا از شکل مخفف استفاده می شود؟[note/]
[p]id="19"[p/]
هدف از تعریف کردن الگوها بن شکل مخفف مانند MVC، غالبا برای ساده تر کردن صحبت و مکاتبه بین توسعه دهندگان می باشد. بجای آنکه به همکارتان بگویید؛ "بیا یک دسترسی داده بسازیم، سپس بیا جدا کنیم لایه ها را برای کنترل نمایش آن ها، و بعد از آن بیا یک لایه در میان آن قرار دهیم که آن را تنظیم و مرتب کند." می توانید از این خصوصیت استفاده کرده و بگویید؛ "بیا در اینجا از الگوی MVC استفاده کنیم."
[/p]
[/note]

[p]id="20"[p/]
جنگو الگوی MVC را به اندازه ی کافی از نزدیک دنبال می کند به طوری که می توان آن را یک فریم ورک MVC نامید. در زیر نحوه ی تقسیم بندی M، V و C به درون جنگو را مشاهده می کنید:
[/p]

[ul][ul/]
[li]id="21"[li/]
M، بخش دسترسی به داده می باشد که توسط لایه پایگاه داده جنگو کنترل می شود و در این فصل توضیح داده خواهد شد.
[/li]

[li]id="22"[li/]
V، انتخاب داده برای نمایش و نحوه ی نمایش آن، که با view ها و template ها کنترل شده است.
[/li]

[li]id="23"[li/]
C، بخشی که توسط خود فریم ورک کنترل می شود، بدینصورت که با توجه به URLconf مشخص شده تابع پایتون مناسب برای URL داده شده را فراخوانی می کند.
[/li]
[/ul]

[p]id="24"[p/]
به دلیل آنکه [چپ]C ("Controler")[/چپ] توسط خود فریم فرک کنترل می شود و بیشترین تحرکات در models ،template و view ها اتفاق می افتد، جنگو به صورت یک فریم ورک MTV نیز شناخته می شود. در الگوی توسعه ی  MTV:
[/p]

[ul][ul/]
[li]id="25"[li/]
M مخفف "Model"، لایه ی دسترسی داده می باشد. این لایه حاوی همه اطلاعات درباره ی داده یعنی نحوه ی دسترسی به داده، نحوه ی معتبر ساختن داده، رفتارهایی که داده دارد و ارتباط بین داده می باشد.
[/li]

[li]id="26"[li/]
T مخفف "Template"، لایه ی نمایش می باشد. این لایه حاوی مسائلی درباره ی نحوه ی نمایش می باشد: این که اطلاعات باید به چه نحوی روی یک صفحه ی وب و یا سند دیگر نمایش داده شود.
[/li]

[li]id="27"[li/]
V مخفف "view"، لایه ی منطق برنامه می باشد. این لایه حاوی منطق برنامه برای دسترسی به model و ارائه ی به template مناسب می باشد. می توانید این لایه را به صورت پلی بین model ها و template ها تصور کنید.
[/li]
[/ul]

[p]id="28"[p/]
در صورتیکه با فریم ورک های دیگر توسعه ی وب مانند Ruby on Rails کار کرده باشید، ممکن است تصور کنید view های جنگو نقش "Controller" را بازی می کنند و template ها هم در حکم "views" می باشند. همچین تفسیری درباره ی MVC مایه ی تاسف می باشد. تفسیر جنگو نسبت به MVC، این است که "view" ارائه دادن داده به کاربر را شرح می دهد، این لزوما تنها ظاهر داده نمی باشد، بلکه منظور داده ی ارائه شده می باشد. در مقابل، Ruby on Rails و فریم ورک های مانند آن پیشنهاد می کنند که تصمیم گیری درباره ی اینکه کدام داده باید به کاربر ارائه داده شود از جمله وظایف controller می باشد، در حالیکه، ظاهر داده به طور موکد بر عهده ی view می باشد.
[/p]

[h3]id="29"[h3/]
پیکربندی پایگاه داده
[/h3]

[p]id="30"[p/]
با در نظر گرفتن تمام فلسفه های گفته شد، اجازه دهید کار با لایه ی پایگاه داده ی جنگو را شروع کنیم. در ابتدا، نیاز به تعدادی پیکر بندی اولیه می باشد، در واقع بایستی به جنگو گفته شود که از کدام سرور پایگاه داده استفاده خواهد کرد و به چه صورت به آن متصل خواهد شد.
[/p]

[p]id="31"[p/]
فرض بر این است که سرور پایگاه داده نصب و فعال شده است، و همچنین یک پایگاه داده درون آن ساخته شده است (به عنوان مثال، با استفاده از دستور CREATE DATABASE STATEMENT). در صورتیکه از SQLite استفاده می کنید، به هیچگونه نصب نیاز نخواهد بود، زیر SQLite از فایل های مستقلی روی سیستم برای ذخیره ی داده های خود استفاده می کند.
[/p]

[p]id="32"[p/]
درست مانند TEMPLATE_DIRS که در فصل گذشته استفاده شد، پیکربندی مربوط به پایگاه داده نیز درون فایل settings می باشد:
[/p]

[code]
DATABASE_ENGINE = ''
DATABASE_NAME = ''
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''
[/code]

[p]id="33"[p/]
در زیر خلاصه هایی از هر تنظیم توضیح داده شده است:
[/p]

[ul][ul/]
[li]id="34"[li/]
DATABASE_ENGINE به جنگو می گوید که کدام موتور پایگاه داده استفاده می شود. در صورتیکه می خواهید از یک پایگاه داده درون جنگو استفاده کنید، تنظیم DATABASE_ENGINE باید یکی از رشته های داخل جدول 1-5 باشد.
[/li]

[puzzle]جدول ۱-۵[puzzle/]
[tr][tr/]
[th]width="20%"[th/]
تنظیم
[/th]

[th]width="15%"[th/]
پایگاه داده
[/th]

[th]width="65%"[th/]
Adaper مورد نیاز
[/th]
[/tr]

[tr][tr/]
[td][td/]
postgresql
[/td]

[td][td/]
PostgreSQL
[/td]

[td][td/]
psycopg version 1.x, http://www.djangoproject.com/r/python-pgsql/1/.
[/td]
[/tr]

[tr][tr/]
[td][td/]
postgresql_psycopg2
[/td]

[td][td/]
PostgreSQL
[/td]

[td][td/]
psycopg version 2.x, http://www.djangoproject.com/r/python-pgsql/.
[/td]
[/tr]

[tr][tr/]
[td][td/]
mysql
[/td]

[td][td/]
MySQL
[/td]

[td][td/]
MySQLdb, http://www.djangoproject.com/r/python-mysql/.
[/td]
[/tr]

[tr][tr/]
[td][td/]
sqlite3
[/td]

[td][td/]
SQLite
[/td]

[td][td/]
No adapter needed if using Python 2.5+. Otherwise, pysqlite, http://www.djangoproject.com/r/python-sqlite/.
[/td]
[/tr]

[tr][tr/]
[td][td/]
oracle
[/td]

[td][td/]
Oracle
[/td]

[td][td/]
cx_Oracle, http://www.djangoproject.com/r/python-oracle/.
[/td]
[/puzzle]

[p]id="35"[p/]
توجه داشته باشید برای استفاده از هر کدام نیاز به دانلود و نصب adapter مناسب خود می باشد. هر کدام از پایگاه های داده ی فوق به صورت آزاد درون وب در دسترس می باشند؛ تنها کافیست به سایت مورد نظر که درون جدول 1-5 آمده است مراجعه کرده آن را دانلود کنید. در صورتیکه با سیستم عامل لینوکس کار می کنید، package-management سیستم شما ممکن است package های مناسبی را ارئه دهد. (برای مثال به دنبال package هایی با نام python-postgresql یا python‑psycopg بگردید.)
[/p]

[p]id="36"[p/]
مثال:
[/p]

[code]
DATABASE_ENGINE = 'postgresql_psycopg2'
[/code]

[p]id="37"[p/]
DATABASE_NAME نام پایگاه داده ی شما را به جنگو اطلاع می دهد:
[/p]

[code]
DATABASE_NAME = 'mydb'
[/code]

[p]id="38"[p/]
در صورتیکه از SQLite استفاده می کنید، آدرس کامل پایگاه داده ی خود را درون این تنظیم قرار دهید:
[/p]

[code]
DATABASE_NAME = '/home/django/mydata.db'
[/code]

[li]id="39"[li/]
DATABASE_USER نام کاربری که برای اتصال به پایگاه داده لازم است را به جنگو اطلاع می دهد.
[/li]

[li]id="40"[li/]
DATABASE_PASSWORD رمز عبوری که برای اتصال به پایگاه داده لازم است را به جنگو اطلاع می دهد. در صورتیکه از SQLite استفاده می کنید یا اینکه می خواهید پسوردی در نظر نگیرید، می توانید آن را خالی بگذارید.
[/li]

[li]id="41"[li/]
DATABASE_HOST host مورد نظری که برای اتصال به پایگاه داده لازم است را به جنگو اطلاع می دهد. در صورتیکه پایگاه داده ی شما همانند نصب جنگو در یک رایانه می باشد (مانند localhost) آن را خالی بگذارید. همچنین اگر از SQLite استفاده می کنید نیز می توانید آن را خالی بگذارید.
[/li]

[p]id="42"[p/]
MySQL در اینجا یک مورد خاص می باشد. در صورتیکه مقدار این تنظیم (DATABASE_HOST) با علامت (/) شروع شود و شما از MySQL استفاده کنید، MySQL از طریق یک Unix socket برای socket تعیین شده متصل خواهد شد:
[/p]

[code]
DATABASE_HOST = '/var/run/mysql'
[/code]
[/ul]

[p]id="43"[p/]
هنگامی که تنظیمات فوق را انجام داده و فایل settings.py ذخیره کردید، ایده ی خوب است که پیکربندی انجام شده را مورد آزمون قرار دهید. برای انجام این کار، مانند فصل گذشته درون دایرکتوری پروژه ی mysite دستور python manage.py shell را اجرا کنید. (همانطور که در فصل گذشته اشاره شد دستور manage.py shell روشی برای اجرای interpreter پایتون، با تنظیمات صحیح فعال شده ی جنگو می باشد. در این مورد این ضروری است، زیرا نیاز است جنگو تنظیمات فایل را به منظور به دست آوردن اطلاعات connection پایگاه داده برای استفاده بداند.)
[/p]

[p]id="44"[p/]
درون خط فرمان، دستورات زیر را به منظور آزمودن پیکربندی پایگاه داده تایپ کنید:
[/p]

[code]
>>> from django.db import connection
>>> cursor = connection.cursor()
[/code]

[p]id="45"[p/]
در صورتیکه اتفاقی رخ ندهد پایگاه داده پیکربندی شده است. در غیر این صورت، پیام خطا را برای بدست آوردن دلیل خطا بررسی کنید. جدول 2-5 برخی از این خطاها را نشان می دهد.
[/p]

[puzzle]جدول ۲-۵[puzzle/]
[tr][tr/]
[th]width="50%"[th/]
راه حل
[/th]

[th]width="50%"[th/]
پیام خطا
[/th]
[/tr]

[tr][tr/]
[td][td/]
تنظیم DATABASE_ENGINE را با چیزی به غیر از رشته ی خالی پر کنید. مقادیر معتبر برای این تنظیم در جدول 1-5 وجود دارد.
[/td]

[td][td/]
You haven't set the DATABASE_ENGINE setting yet.
[/td]
[/tr]

[tr][tr/]
[td][td/]
به جای دستور python از دستور python manage.py shell باید استفاده کرد.
[/td]

[td][td/]
Environment variable DJANGO_SETTINGS_MODULE is undefined.
[/td]
[/tr]

[tr][tr/]
[td][td/]
Adapter پایگاه داده ی مناسبی نصب نشده است (مانند psycopg یا MySQLdb). Adapter ها با جنگو مچ نشده اند، بنابراین می بایست Adapter مورد نظر را دانلود و نصب کنید.
[/td]

[td][td/]
Environment variable DJANGO_SETTINGS_MODULE is undefined.
[/td]
[/tr]

[tr][tr/]
[td][td/]
SQLite
[/td]

[td][td/]
Error loading _____ module: No module named _____.
[/td]
[/tr]

[tr][tr/]
[td]
تنظیم DATABASE_ENGINE را با یک موتور پایگاه داده که در جدول 1-5 وجود دارد پر کنید.
[/td]

[td][td/]
_____ isn't an available database backend.
[/td]
[/tr]

[tr][tr/]
[td][td/]
تنظیم مربوط به DATABASE_USER باید تغییر کنید و همچنین تنظیمی باشد که وجود دارد، و یا یک نام کاربری برای پایگاه داده باید ساخته شود.
[/td]

[td][td/]
role _____ does not exist
[/td]
[/tr]

[tr][tr/]
[td][td/]
اطمینان حاصل کنید که DATABASE_HOST و DATABASE_PORT صحیح بوده و سرور پایگاه داده در حال اجرا می باشد.
[/td]
[td][td/]
could not connect to server
[/td]
[/tr]
[/puzzle]

[h3]id="46"[h3/]
ایجاد اولین App
[/h3]

[p]id="47"[p/]
اکنون که مشخص شد اتصال به پایگاه داده با موفقیت انجام شده است، زمان آن رسیده است که یک app برای جنگو ایجاد کنیم، app یک بسته از کد جنگو می باشد که model ها و view ها در آن قرار می گیرد، که همگی با هم درون یک پکیج پایتون قرار گرفته اند و یک برنامه (application) جنگو را نمایش می دهند.
[/p]

[p]id="48"[p/]
در فصل دوم نحوه ی ساختن یک پروژه ی جنگو توضیح داده شد، اکنون فرق بین یک پروژه با یک app(اپلیکیشن)در چیست؟ تفاوت آن در پیکربندی در مقابل کد است:
[/p]

[ul][ul/]
[li]id="49"[li/]
یک پروژه یک نمونه از یک مجموعه ی خاص از app های جنگو به همراه پیکربندی برای آن ها می باشد.
[/li]

[p]id="50"[p/]
از نظر فنی، تنها فرق اساسی که در پروژه وجود دارد ایجاد یک فایل settings می باشد، که اطلاعات connection پایگاه داده، لیست app های نصب شده، تنظیم TEMPLATE_DIRS و غیره را تعریف می کند.
[/p]

[li]id="51"[li/]
app یک دسته ی قابل حمل از عمکرد جنگو می باشد، که معمولا شامل model ها و view ها می باشد که با هم در یک پکیج پایتون قرار دارند.
[/li]

[p]id="52"[p/]
برای مثال، جنگو به همراه تعدادی از app ها، از قبیل سیستم کامنت و رابط خودکار مدیر، ارائه شده است، نکته ی قابل توجه درباره ی این app ها این است که، آن ها قابل حمل می باشند بدین معنی که می تواند آن ها را در چندین پروژه دیگر نیز دوباره استفاد کرد.
[/p]
[/ul]

[p]id="53"[p/]
مقدار بسیار کمی قوانین سخت و محکم نسبت به وفق دادن کد جنگو با این طرح وجود دارد. در صورتیکه بخواهید یک وب سایت ساده بسازید، ممکن است تنها از یک app استفاده کنید. و اگر می خواهید یک وب سایت بزرگ و پیچیده با چندین قسمت مرتبط به هم مانند یک سیستم تجارت الکترونیک و یک تابلوی پیام (message board) بسازید، احتمالا این قسمت ها را درون app ها جدا قرار خواهید داد، به طوری که قادر باشید در صورت نیاز آن ها را به صورت منحصر به فرد در اینده استفاده کنید.
[/p]

[p]id="54"[p/]
در واقع، لزوما همیشه نیاز به ساختن app ها در پروژه نیست، به عنوان نمونه توابع view که تاکنون ساخته شده است حاکی این موضوع می باشد. در آن مواردبه سادگی یک فایل views.py ساخته شده و با توابع view مورد نیاز درون آن پر می شد، و URLconf نیز به آن توابع اشاره می کرد. نیازی به app ها نبود.
[/p]

[p]id="55"[p/]
با این وجود، در یک صورت باید از app ها استفاده شود: در صورتیکه شما از لایه ی پایگاه داده ی (models) جنگو استفاده می کنید، باید یک app جنگو بسازید. model ها باید درون app ها ایجاد شوند. در نتیجه، به منظور ساختن model ها، نیزا به ساختن یک app جدید می باشد.
[/p]

[p]id="56"[p/]
درون دایرکتوری پروژه ی mysite، دستور زیر را برای ساختن app مورد نظر با نام books اجرا کنید:
[/p]

[pre][pre/]
python manage.py startapp books
[/pre]

[p]id="57"[p/]
دستور فوق هیچ خروجی ای را تولید نمی کند، در عوض دایرکتوری books را درون دایرکتوری mysite می سازد. در زیر محتویات این دایرکتوری را مشاهده می کند:
[/p]

[pre][pre/]
books/
    __init__.py
    models.py
    tests.py
    views.py
[/pre]

[p]id="58"[p/]
این فایل ها حاوی model ها و view ها برای این app می باشد.
[/p]

[p]id="59"[p/]
درون ویرایشگر متن مورد علاقه ی خود نگاهی به فایل های models.py و views.py بیاندازید. جفت فایل ها خالی هستند، به غیر از کامنت ها و یک import که درون فایل models.py قرار دارد.
[/p]

[h3]id="60"[h3/]
تعریف Model ها در پایتون
[/h3]

[p]id="61"[p/]
همانطور که پیش تر در این فصل توضیح داده شد، "M" در "MTV" مخفف "Model" می باشد. model جنگو توصیف و شرح داده در پایگاه داده ی شما می باشد، که به صورت کد پایتون نمایش داده می شود. model لایه ی داده ی شما می باشد معادل عبارات SQL مانند CREATE TABLE با این تفاوت که این عبارات بجای SQL درون پایتون می باشند و همچنین آن ها شامل مواردی بیشتر از تعریف ستون های پایگاه داده می باشند. جنگو برای اجرای کد های SQL در پشت صحنه و برگرداندن ساختارهای داده ی پایتون مناسب از model ها استفاده می کند که از طریق آن ها ردیف های جداول پایگاه داده را نمایش می دهد. جنگو همچنین از model ها برای نمایش مفاهیم سطح بالا که SQL لزوما قادر به کنترل آن ها نمی باشد نیز استفاده می شود.
[/p]

[p]id="62"[p/]
در صورتیکه با پایگاه های داده آشنا می باشید، این تفکر برای شما ایجاد می شود که "آیا تعریف کردن data model ها بجای SQL درون پایتون کار زائد و اضافه ای نیست؟" جنگو به چندین دلیل به این روش عمل می کند:
[/p]

[ul][ul/]
[li]id="63"[li/]
درون گرایی (استفاده از کد های SQL) مستلزم بار اضافی بوده و همچنین ناقص می باشد. به منظور تهیه ی API ها برای دسترسی به داده، جنگو به طریقی نیاز به شناختن لایه ی پایگاه داده دارد، و دو روش برای انجام آن وجود دارد. روش اول به طور واضح توضیح دادن داده در پایتون می باشد، و روش دوم تعیین data model ها درون پایگاه داده در هنگام اجرا می باشد.
[/li]

[p]id="64"[p/]
روش دوم تمیز تر به نظر می رسد، زیرا داده های جداول شما در یک جا می باشند، ولی این روش دارای مشکلاتی می باشد. اول اینکه تعیین داده های درون پایگاه داده  در زمان اجرا بدیهی است که نیازمند یک بار اضافه خواهد بود. در صورتیکه فریم ورک در هر زمان بخواهد درون پایگاه داده اعمالی را انجام دهد خود به خود یک درخواست را پردازش کرده است، و یا حتی، در زمان اولیه وب سرور ممکن است یک بار اضافی در سطح غیر قابل قبول را متحمل شود. دوم آنکه برخی از پایگاه های داده، به ویژه نسخه های قدیمی MySQL، metadata مناسبی را به طور دقیق ذخیره نمی کنند. 
[/p]

[li]id="65"[li/]
کد نویسی در پایتون لذت بخش می باشد، و نگه داشتن همه چیز در محدوده ی کد پایتون باعث می شود تعداد باری که شما را مجبور کند محیط کد نویسی را تغییر دهد کم می کند. این موضوع یعنی نگه داشتن برنامه نویس در یک محیط کد نویسی بهره وری و راندمان را تا حد امکان افزایش می دهد. نوشتن کد SQL و سپس پایتون و دوباره SQL کاری ذهنیت برنامه نویس را مختل خواهد کرد.
[/li]

[li]id="66"[li/]
داشتن data model های ذخیره شده به صورت کد بجای استفاده مستقیم از پایگاه داده، کنترل model هار بسیار آسان تر خواهد کرد. با این روش می توان به سادگی رد تغییرات در لایه های داده را دنبال کرد.
[/li]

[li]id="67"[li/]
SQL تنها اجازه ی استفاده از داده های قطعی موجود می دهد، اغلب سیستم های پایگاه داده، به عنوان مثال؛ داده های تخصصی برای نمایش دادن آدرس های email یا URL را تهیه نمی کنند. در صورتیکه model های جنگو این کار را انجام می دهند. مزیت داده های نوع سطح بالا بهره وری بیشتر آن ها و قابلیت دوباره استفاده شدن آن ها می باشد.
[/li]

[li]id="68"[li/]
SQL در پایگاه های داده ی مختلف یکجور نبوده و ناسازگار می باشد. بدین معنی که جملات و عبارت SQL برای مثال join ها و یا ... در پایگاه های داده ی مختلف مانند MySQL، PostgreSQL و یا SQLite ممکن است متفاوت از یکدیگر پیاده سازی شوند و هرکدام به روش خود آن را پیاده سازی کنند.
[/li]
[/ul]

[p]id="69"[p/]
تنها ایراد در این روش (استفاده از data model پایتون) این است که کدهای پایتون حالت همزمانی و موازات را به طور واقعی با پایگاه داده ندارند. در صورتیکه در model جنگو تغییر ایجاد کنید، نیاز می باشد که همان تغییرات را نیز درون پایگاه داده انجام دهید تا پایگاه داده با model شما سازگاری خود را حفظ کند. در ادامه ی این فصل استراتژی هایی توضیح داده خواهد شد که از طریق آن ها خواهید توانست این مشکلات را کنترل کنید.
[/p]

[h3]id="70"[h3/]
اولین Model شما
[/h3]

[p]id="71"[p/]
برای داشتن مثالی که هم در این فصل و فصل بعدی بتوان از آن استفاده کرد و آن را پیشرفت داد، بر روی لایه ی داده ی book/author/publisher تمرکز خواهد شد. از این مثال به دلیل اینکه دارای رابطه های شناخته شده ای بین books، authors و publishers می باشد، و داده های استفاده شده داده های مقدماتی استفاده شده در SQL می باشد.
[/p]

[p]id="72"[p/]
داده های استفاده شده با خصوصیات زیر فرض شده اند:
[/p]

[ul][ul/]
[li]id="73"[li/]
یک نویسنده دارای یک نام، یک فامیلی و یک نشانی پست الکترونیک می باشد.
[/li]

[li]id="74"[li/]
یک ناشر دارای یک نام، یک نشانی کوچه، یک شهر، یک استان، یک کشور و یک وب سایت می باشد.
[/li]

[li]id="75"[li/]
یک کتاب دارای یک عنوان و یک تاریخ انتشار می باشد. همچنین هر کتاب دارای یک یا بیشتر نویسنده (رابطه ی چند به چند با authors) و یک ناشر (رابطه ی یک به چند به publishers) می باشد.
[/li]
[/ul]

[p]id="76"[p/]
اولین قدم برای استفاده کردن لایه ی پایگاه داده با جنگو، بیان آن به صورت کد پایتون می باشد. درون فایل models.py که با استفاده از دستور startapp ساخته شده است، کد زیر را وارد کنید:
[/p]

[code]
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
[/code]

[p]id="77"[p/]
اجازه دهید کد فوق را به طور اجمالی مورد بررسی قرار دهیم. اولین نکته ی قابل توجه این است که هر model به صورت یک کلاس پایتون نمایش داده شده است و هر model کلاس فرزند از کلاس پدر django.db.models.Model می باشد. کلاس پدر Model، حاوی تمام ابزار آلات ضروری برای ساختن آبجکت هایی می باشد که توانایی تعامل با یک پایگاه داده را داشته باشند. مشاهده می کنید که تعریف فیلدها به چه اندازه مختصر و ساده می باشند. باور کنید یا نه، این تمام کدی می باشد که برای داشتن دسترسی داده ی اولیه با جنگو لازم است.
[/p]

[p]id="78"[p/]
هر model عموما با یک جدول پایگاه داده و هر attribute در یک model با یک ستون جدول در پایگاه داده مطابق می باشد، نام attribute مطابق با نام ستون، و نوع فیلد (مانند CharField) مطابق با نوع ستون (مانند varchar) می باشد. برای مثال مدل Publisher برابر با جدول زیر می باشد (با فرض عبارت CREATE TABLE درون پایگاه داده ی PostgreSQL):
[/p]

[code sql]
CREATE TABLE "books_publisher" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(30) NOT NULL,
    "address" varchar(50) NOT NULL,
    "city" varchar(60) NOT NULL,
    "state_province" varchar(30) NOT NULL,
    "country" varchar(50) NOT NULL,
    "website" varchar(200) NOT NULL
);
[/code]

[p]id="79"[p/]
در واقع، جنگو می تواند عبارت CREATE TABLE را به صورت خودکار تولید کند که در کد فوق مشاهده کردید.
[/p]

[p]id="80"[p/]
در این قانون که برای هر جدول پایگاه داده، یک کلاس در نظر گرفته می شود، در مورد رابطه های چند به چند یک استثنا وجود دارد. در مثال مدل های فوق، Book دارای یک فیلد چند به چند با نام authors می باشد. این فیلد مشخص می کند که هر کتاب دارای یک یا چند نویسنده می باشد، در صورتیکه جدول پایگاه داده Book دارای ستونی به نام authors نمی باشد. در عوض، جنگو یک جدول اضافه می سازد (یک "join table" چند به چند) که رابطه بین کتاب ها و نویسندگان را کنترل می کند.
[/p]

[p]id="81"[p/]
در پایان، توجه داشته باشید که به طور صریح برای هر یک از مدل ها یک کلید اصلی (primary key) تعریف نشده است. جنگو به صورت خودکار برای هر مدل یک فیلد auto_incremen integer primary key ایجاد می کند که id نام دارد. هر مدل جنگو لازم است یک ستون primary key داشته باشد.
[/p]

[h3]id="82"[h3/]
نصب کردن Model
[/h3]

[p]id="83"[p/]
کد مربوط به مدل ها نوشته شد، حالا اجازه دهید جدول ها را درون پایگاه داده نیز ایجاد کنیم. به منظور انجام این کار؛ قدم اول این است که مدل های ساخته شده درون پروژه جنگو را فعال کنیم. برای انجام این کار باید app مورد نظر یعنی books را به لیست "installed apps" درون فایل settings اضافه کنیم.
[/p]

[p]id="84"[p/]
فایل settings.py را دوباره باز کرده، و تنظیم INSTALLED_APPS را پیدا کنید. INSTALLED_APPS به جنگو می گوید که کدام app ها برای پروژه مورد نظر فعال هستند. به طور پیشفرض، این تنظیم به این شکل خواهد بود:
[/p]

[code]
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
)
[/code]

[p]id="85"[p/]
به طور موفت با گذاشتن علامت (#) در ابتدای هر کدام از رشته ها آن ها را کامنت کنید. (این رشته ها موارد کامنت شده ای برای راحتی کار می باشند که در فصل های بعدی آن ها را فعال کرده و در مورد آن ها بحث خواهیم کرد.) همچنین تنظیمات مربوط به MIDDLEWARE_CLASSES را نیز کامنت کنید؛ مقادیر پیشفرض در MIDDLEWARE_CLASSES به برخی از app هایی که ما آن ها را کامنت کردیم وابسته می باشند. سپس 'mysite.books'را به لیست INSTALLED_APPS اضافه کنید، در پایان تنظیم انجام داده شده چیزی شبیه به مثال زیر خواهد بود:
[/p]

[code]
MIDDLEWARE_CLASSES = (
    # 'django.middleware.common.CommonMiddleware',
    # 'django.contrib.sessions.middleware.SessionMiddleware',
    # 'django.contrib.auth.middleware.AuthenticationMiddleware',
)

INSTALLED_APPS = (
    # 'django.contrib.auth',
    # 'django.contrib.contenttypes',
    # 'django.contrib.sessions',
    # 'django.contrib.sites',
    'mysite.books',
)
[/code]

[p]id="86"[p/]
(همانطور که در فصل گذشته، هنگام تنظیم TEMPLATE_DIRS گفته شد، لازم است حتما یک علمت کاما (,) در انتهای mysite.books قرار دهید، زیرا mysite.books در اینجا یک تک المان تاپل پایتون می باشد، اتفاقا، نویسندگان این کتاب ترجیح می دهند بعد از هر المان تاپل، بدون در نظر گرفتن این که یک تک المان است یا خیر، یک کاما در انتهای آن قرار میدهند. این کار باعث می شود از فراموش کردن قرار دادن کاما در انتهای المان های تک تاپل جلوگیری شود، و گذاشتن کامای اضافه هیچ مشکلی به وجود نخواهد آورد.)
[/p]

[p]id="87"[p/]
'mysite.books' به app ای که با کار می کنیم اشاره می کند. هر app ای که در تنظیم INSTALLED_APPS قرار دارد با آدرس کامل پایتون آن نمایش داده می شود (مسیر پکیج ها با نقطه جدا شده و به پکیج app هدایت می شوند.)
[/p]

[p]id="88"[p/]
اکنون که app مورد نظر در فایل settings فعال شد، می توانیم جداول پایگاه داده را درون پایگاه داده ایجاد کنیم. ابتدا، اجازه دهید با دستور زیر از معتبر بودن کد های برنامه اطمینان حاصل کنیم:
[/p]

[pre][pre/]
python manage.py validate
[/pre]

[p]id="89"[p/]
دستور validate بررسی می کند که ایا کدها و منطق مدل های نوشته صحیح می باشد یا خیر. در صورتیکه همه چیز درست باشد، شما پیام message 0 errors found را مشاهده خواهید کرد. در غیر اینصورت، اطمینان حاصل کنید کدهای مدل شما صحیح می باشد. خطای خروجی، اطلاعات مفیدی درباره ی ایراد موجود در کد، در اختیار شما می گذارد.
[/p]

[p]id="90"[p/]
هر زمان که تصور کردید مشکلاتی درون مدل ها وجود دارد، دستور python manage validate را اجرا کنید. دستور فوق به شما کمک می کند تا تمام مشکلات موجود در مدل را بر طرف کنید.
[/p]

[p]id="91"[p/]
در صورتیکه کد مربوط به مدل شما معتبر می باشد، دستور زیر را برای تولید عبارت های CREATE TABE مربوط به مدل ها در app مورد نظر (books) وارد کنید:
[/p]

[pre][pre/]
python manage.py sqlall books
[/pre]

[p]id="92"[p/]
در دستور فوق، books نام app می باشد. این نام همان چیزی است که شما با اجرای دستور manage.py startapp ایجاد کرده اید. هنگامی که شما دستور فوق manage.py sqlall books را اجرا می کنید چیزی شبیه به این را در خروجی مشاهده خواهید کرد:
[/p]

[code sql]
BEGIN;
CREATE TABLE "books_publisher" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(30) NOT NULL,
    "address" varchar(50) NOT NULL,
    "city" varchar(60) NOT NULL,
    "state_province" varchar(30) NOT NULL,
    "country" varchar(50) NOT NULL,
    "website" varchar(200) NOT NULL
)
;
CREATE TABLE "books_author" (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(40) NOT NULL,
    "email" varchar(75) NOT NULL
)
;
CREATE TABLE "books_book" (
    "id" serial NOT NULL PRIMARY KEY,
    "title" varchar(100) NOT NULL,
    "publisher_id" integer NOT NULL REFERENCES "books_publisher" ("id") DEFERRABLE INITIALLY DEFERRED,
    "publication_date" date NOT NULL
)
;
CREATE TABLE "books_book_authors" (
    "id" serial NOT NULL PRIMARY KEY,
    "book_id" integer NOT NULL REFERENCES "books_book" ("id") DEFERRABLE INITIALLY DEFERRED,
    "author_id" integer NOT NULL REFERENCES "books_author" ("id") DEFERRABLE INITIALLY DEFERRED,
    UNIQUE ("book_id", "author_id")
)
;
CREATE INDEX "books_book_publisher_id" ON "books_book" ("publisher_id");
COMMIT;
[/code]

[p]id="93"[p/]
به نکات زیر توجه کنید:
[/p]

[ul][ul/]
[li]id="94"[li/]
نام جدول ها به طور خودکار با ترکیب نام app (books) و نام مدل (publisher، book و author) به صورت حروف کوچک تولید می شود. 
[/li]

[li]id="95"[li/]
همانطور که پیش تر توضیح داده شد، جنگو برای هر جدول به طور خودکار یک کلید اصلی (با نام id) اضافه می کند.
[/li]

[li]id="96"[li/]
رابطه ی کلید خارجی با عبارت REFERENCES، صریح و روشن ساخته شده است.
[/li]

[li]id="97"[li/]
عبارت CREATE TABLE برای پایگاه داده ای که شما استفاده می کنید مناسب خواهد بود، بنابراین تعیین نوع فیلد مانند auto_increment (MySQL)، serial (PostgreSQL)، یا integer primary key (SQLite) به طور خودکار توسط جنگو انجام خواهد شد. همچنین در مورد کتیشن برای نام ستون ها (مانند استفاده از دابل کتیشن یا تک کتیشن) نیز این موضوع صدق می کند. مثال فوق خروجی برای PostgreSQL می باشد.
[/li]
[/ul]

[p]id="98"[p/]
دستور sqlall، در حقیقت جداول پایگاه داده را تولید نمی کند و به عبارت دیگر پایگاه داده نیز لمس نمی کند، تنها خروجی تولید شده توسط جنگو را به زبان SQL مورد نظر نشان می دهد بنابراین شما می توانید آنچه را که جنگو درون پایگاه داده می خواهد اجرا کند را مشاهده کنید. در صورت تمایل، می توانید این خروجی SQL را درون پایگاه داده ی کلاینت کپی کنید، یا با استفاده از علامت (|) یونیکس آن را به صورت مستقیم ارسال کنید (مانند python manage.py sqlall books | psql mydb). با این وجود، جنگو روشی ساده را برای ارسال خروجی تولید شده به پایگاه داده ارائه کرده است: دستور syncdb:
[/p]

[pre][pre/]
python manage.py syncdb
[/pre]

[p]id="99"[p/]
بعد از اجرای دستور فوق، خروجی شبیه به مثال زیر مشاهده خواهید کرد:
[/p]

[pre][pre/]
Creating table books_publisher
Creating table books_author
Creating table books_book
Installing index for books.Book model
[/pre]

[p]id="100"[p/]
دستور syncdb یک هماهنگی ساده بین مدل ها و پایگاه داده می باشد. دستور فوق تمام مدل های موجود در هر app را درون تنظیم INSTALLED_APPS بررسی می کند، و در صورتیکه جدول مناسب برای مدل های مورد نظر وجود نداشته باشد آن ها را ایجاد می کند. توجه داشته باشید که syncdb تغییرات بوجود آمده در مدل ها و یا حذف مدل ها را با پایگاه داده هماهنگ نمی کند؛ در صورتیکه شما یک تغییر را در مدل ایجاد کرده و یا مدلی را حذف کنید، هنگامی که بخواهید پایگاه داده را با این تغییرات به روز رسانی کنید، دستور syncdb نمی تواند این کار را انجام دهد. (در انتهای همین فصل این موضوع بحث خواهد شد.)
[/p]

[p]id="101"[p/]
در صورتیکه که دستور python manage.py syncdb را دوباره اجرا کنید، اتفاقی رخ نخواهد داد، زیرا هیچ مدل به app مورد نظر (books) اضافه نشده است و یا هیچ app ای به تنظیم INSTALLED_APPS اضافه نشده است. بنابراین اجرای دستور python manage.py syncdb همواره مشکلی بوجود نخواهد آورد.
[/p]

[p]id="102"[p/]
در صورتیکه کنجکاو هستید، می توانید برای لحظاتی به درون خط فرمان پایگاه داده رفته جداول ایجاد شده درون پایگاه داده ی خود را مشاهده کنید. می توانید به صورت دستی دستوراتی را که می خوهید درون خط فرمان کلاینت اجرا کنید (مانند psql برای PostrgreSQL) یا اینکه می توانید دستور python manage.py dbshell، را اجرا کنید، و بسته به تنظیم DATABASE_SERVER، خواهید فهمید کدام خط فرمان اجرا می شود. شیوه ی دوم تقریبا همیشه مناسب تر می باشد.
[/p]

[h3]id="103"[h3/]
اصول اولیه ی دسترسی به داده
[/h3]

[p]id="104"[p/]
هنگامی که شما یک مدل ساخته می شود، جنگو به طور خودکار یک API سطح بالا پایتون را برای کار با آن مدل ها ایجاد می کند. دستور python manage.py shell را اجرا کرده و کدهای زیر را امتحان کنید:
[/p]

[code]
>>> from books.models import Publisher
>>> p1 = Publisher(name='Apress', address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p1.save()
>>> p2 = Publisher(name="O'Reilly", address='10 Fawcett St.',
...     city='Cambridge', state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
>>> p2.save()
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Publisher object>, <Publisher: Publisher object>]
[/code]

[p]id="105"[p/]
چند خط کد فوق کار زیادی را انجام می دهند. نکات برجسته در کد فوق:
[/p]

[ul][ul/]
[li]id="106"[li/]
ابتدا، مدل Publisher به import شده است. با این کار می توان با جدول پایگاه داده که حاوی اطلاعات ناشران می باشد در ارتباط بود.
[/li]

[li]id="107"[li/]
یک آبجکت Publisher با مقدار دهی مقدار دهی اولیه ی آن با مقادیری برای هر فیلد (name، address و غیره ...) ساخته شده است.
[/li]

[li]id="108"[li/]
برای ذخیره ی آبجکت درون پایگاه داده، متد [چپ]save()[/چپ] آن فراخوانی شده است. در پشت صحنه، جنگو عبارت INSERT برای SQL را در اینجا اجرا می کند.
[/li]

[li]id="109"[li/]
برای بازیابی اطلاعات ناشران از پایگاه داده، از attribute مورد نظر Publisher.objects برای بدست آوردن مجموعه تمام ناشران استفاده شده است. لیست تمام آبجکت های Publisher با استفاده از عبارت [چپ]Publisher.objects.all()[/چپ] واکشی شده است. در پشت صحنه جنگو یک عبارت SELECT را به صورت SQL در اینجا اجرا می کند.
[/li]
[/ul]

[p]id="110"[p/]
نکته ای با اهمیتی که در این مورد واضح و یا روشن به نظر نمی رسد اینکه، هنگامی که شما با استفاده از API مدل جنگو در حال ساختن آبجکت ها می باشید، جنگو تا وقتی که متد [چپ]save()[/چپ] را فراخوانی نکنید آبجکت ها را درون پایگاه داده ذخیره نمی کند. 
[/p]

[code]
p1 = Publisher(...)
# At this point, p1 is not saved to the database yet!
p1.save()
# Now it is.
[/code]

[p]id="111"[p/]
در صورتیکه می خواهید یک آبجکت ساخته و آن را درون پایگاه داده با یک حرکت ذخیره کنید، می توانید از متد [چپ]objects.create()[/چپ] استفاده کنید. مثال زیر با مثال قبلی برابر است:
[/p]

[code]
>>> p1 = Publisher.objects.create(name='Apress',
...     address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p2 = Publisher.objects.create(name="O'Reilly",
...     address='10 Fawcett St.', city='Cambridge',
...     state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[/code]

[p]id="112"[p/]
به طور طبیعی می توانید کارهای بسیار زیادی را به استفاده از API پایگاه داده ی جنگو انجام دهید، اما در ابتدا با کارهای کوچک بسنده می کنیم.
[/p]

[h3]id="113"[h3/]
‫اضافه كردن نمايش رشته اي براي مدل‬
[/h3]

[p]id="114"[p/]
هنگامی که لیستی از ناشران را چاپ می کنیم، خروجی مفیدی نمایش داده نمی شود و بخش های آبجکت به هیچ وجه قابل تشخیص نیستند:
[/p]

[pre][pre/]
[<Publisher: Publisher object>, <Publisher: Publisher object>]
[/pre]

[p]id="115"[p/]
می توان این مشکل را به راحتی با اضافه کردن متد [چپ]__unicode__()[/چپ] به کلاس Publisher حل کرد. متد [چپ]__unicode__()[/چپ] به پایتون می گوید که یک آبجکت را به چه شکل در خروجی نمایش دهد. می توانید نحوه ی استفاده از آن را در عمل با اضافه کردن یک متد [چپ]__unicode__()[/چپ] درون سه مدل فوق مشاهده کنید:
[/p]

[code]
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    def __unicode__(self):
        return self.title
[/code]

[p]id="116"[p/]
همانطور که مشاهده می کنید، متد [چپ]__unicode__()[/چپ] می تواند هر آنچه را که برای برای نمایش یک آبجکت نیاز است انجام دهید. در مثال فوق متدهای [چپ]__unicode__()[/چپ] برای Publisher و Book به سادگی نام و عنوان آبجکت را به ترتیب برمی گردانند، ولی متد [چپ]__unicode__()[/چپ] برای Author کمی پیچیده تر از بقیه می باشد، بدین صورت که فیلد های first_name و last_name را به یک فاصله به هم وصل کرده و بر می گرداند.
[/p]

[p]id="117"[p/]
تنها الزام برای متد [چپ]__unicode__()[/چپ] این است که یک آبجکت یونیکد را بر می گرداند. در صورتیکه متد [چپ]__unicode__()[/چپ] یک آبجکت یونیکد را بر نگرداند به عنوان مثال یک integer بر گرداند، در اینصورت پایتون خطای TypeError را با پیامی مانند "coercing to Unicode: need string or buffer, int found"ایجاد خواهد کرد.
[/p]

[note]‫آبجكت هاي يونيكد‬[note/]
[p]id="118"[p/]
آبجکت یونیکد چیست؟
[/p]

[p]id="119"[p/]
می توانید بدین شکل تصور کنید که آبجکت یونیکد یک رشته ی پایتون است که می تواند با بیشتر از یک میلیون نوع محتلف حروف را کار کرده و آن ها را کنترل کند، از نسخه های حروف لهجه دار لاتین، حروف غیر لاتین گرفته تا نمادها و علامت های مبهم و نا مفهوم.
[/p]

[p]id="120"[p/]
رشته های معمولی پایتون رمزی شده (encoded) می باشند، بدین معنی که آن ها به صورت رمز شده مانند ASCII، ISO-8859-1 یا UTF-8 استفاده می شوند. در صورتیکه بخواهید حروف تجملی (هرچیزی خارج از 128 حرف ASCII مانند 0-9 و A-Z) را درون یک رشته ی معمولی پایتون ذخیره کنید، این حروف هنگام چاپ و یا نمایش به صورت به هم ریخته در می ایند. مشکلات زمانی رخ می دهند که شما داده ای را درون یک encoding ذخیره کرده و سعی می کنید آن را با یک encoding متفاوت دیگر ترکیب کنید و یا سعی می کنید آن را درون یک برنامه که دارای یک encoding مشخص می باشد نمایش دهید. همه ی ما صفحات وب و پست الکترونیکی را مشاهده کرده ایم که با حالت "??? ??????" و یا دیگر حروف خراب شده اند؛ این مشکلات عموما مشکلات encoding تلقی می شوند.
[/p]

[p]id="121"[p/]
آبجکت های یونیکد، اگر چه encoding ندارند؛ ولی آن ها از یک مجموعه از حروف جهانی و سازگار که "Unicode" نامیده می شوند استفاده می کنند. هنگامی که شما با آبجکت های یونیکد در پایتون سر و کار دارید، می توانید بدون هیچگونه نگرانی نسبت به مسائل encoding آن ها را با یکدیگر ترکیب و استفاده کنید.
[/p]

[p]id="122"[p/]
جنگو در سرتاسر فریم ورک از آبجکت های یونیکد استفاده می کند. آبجکت های مدل به صورت آبجکت های یونیکد بازیابی شده اند، view ها با داده ی یونیکد ارتباط برقرار می کنند و template ها به صورت یونیکد ارائه می شوند. عموما، توسعه دهندگان درون فریم ورک جنگو هیچگونه نگرانی نسبت به درست بودن encoding درون برنامه های نوشته شده توسط جنگو نخواهند داشت.
[/p]

[p]id="123"[p/]
توجه داشته باشید که سطح بالا بودن مطالب در اینجا باعث می شود که اطلاعات شما در مورد آبجکت های یونیکد کمی گمگ و مبهم باشد، در صورتیکه می خواهید می توانید در نشانی زیر مورد آن اطلاعات بیشتری کسب کنید.
[/p]

[p]id="124"[p/]
http://www.joelonsoftware.com/articles/Unicode.html
[/p]

[/note]

[p]id="125"[p/]
برای اینکه تغییرات ایجاد شده درون مدل ها (اضافه کردن متد [چپ]__unicode__()[/چپ]) اعمال شود، از shell پایتون خارج شده و با دستور python manage.py shell دوباره وارد آن شوید. (این ساده ترین راه برای اعمال تغییرات ایجاد شده می باشد) حالا لیست آبجکت های Publisher قابل فهم تر شده اند:
[/p]

[code]
>>> from books.models import Publisher
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Apress>, <Publisher: O'Reilly>]
[/code]

[p]id="126"[p/]
اطمینان حاصل کنید که تمام مدل های تعریف شده دارای متد [چپ]__unicode__()[/چپ] می باشند، نه فقط برای راحتی خودتان هنگامی که از interactive interpreter استفاده می کنید، بلکه جنگو نیز در مکان های زیادی از خروجی [چپ]__unicode__()[/چپ] برای نمایش آبجکت ها استفاده می کند.
[/p]

[p]id="127"[p/]
در پایان، توجه داشته باشید که [چپ]__unicode__()[/چپ] یک مثال خوب برای اضافه کردن یک رفتار برای مدل ها می باشد. یک مدل جنگو بیشتر از جدول لایه پایگاه داده برای یک آبجکت توضیح می دهد؛ همچنین مدل جنگو هر عملکردی را که آبجکت نحوه انجام آن را می داند را توضیح دهد. [چپ]__unicode__()[/چپ] یک مثال برای عملکرد می باشد بدین معنی که یک مدل نحوه ی نمایش خود را می داند.
[/p]

[h3]id="128"[h3/]
‫درج و به روز رساني داده‬
[/h3]

[p]id="129"[p/]
طریقه ی درج کردن داده درون پایگاه داده را مشاهده کردید: ابتدا یک نمونه از یک مدل را با استفاده از ارگومان های آن مانند زیر ساخته:
[/p]

[code]
>>> p = Publisher(name='Apress',
...         address='2855 Telegraph Ave.',
...         city='Berkeley',
...         state_province='CA',
...         country='U.S.A.',
...         website='http://www.apress.com/')
[/code]

[p]id="130"[p/]
همانطور که در کد فوق ملاحظه می کنید، حرکت فوق تعریف اولیه ی یک کلاس مدل می باشد و پایگاه داده به هیچ وجه لمس نشده است. رکورد مورد نظر تا زمانی که متد [چپ]save()[/چپ] فراخوانی نشود درون پایگاه داده ذخیره نخواهد شد:
[/p]

[code]
>>> p.save()
[/code]

[p]id="131"[p/]
عملیات بالا را تقریبا می تواند به شکل زیر به زبان SQL ترجمه کرد:
[/p]

[code sql]
INSERT INTO books_publisher
    (name, address, city, state_province, country, website)
VALUES
    ('Apress', '2855 Telegraph Ave.', 'Berkeley', 'CA',
     'U.S.A.', 'http://www.apress.com/');
[/code]

[p]id="132"[p/]
به دلیل آنکه مدل Publisher از یک کلید اصلی به نام id که با خاصیت افزایش خودکار تعریف شده است استفاده می کند، نخستین فراخوانی [چپ]save()[/چپ] یک کار بیشتر انجام می دهد: ارزش کلید اصلی را برای رکورد محاسبه کرده و آن را درون attribute مورد نظر یعنی id که درون نمونه (instance) می باشد، قرار می دهد:
[/p]

[code]
>>> p.id
52    # this will differ based on your own data
[/code]

[p]id="133"[p/]
فراخوانی های بعدی [چپ]save()[/چپ] رکورد را در مکانی ذخیره می کند، بدون ساختن رکورد جدید (مانند عملکرد عبارت Upadate به جای INSERT در SQL)
[/p]

[code]
>>> p.name = 'Apress Publishing'
>>> p.save()
[/code]

[p]id="134"[p/]
عملیات فوق را می توان تقریبا به شکل زیر به SQL تبدیل کرد:
[/p]

[code sql]
UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
[/code]

[p]id="135"[p/]
بله، توجه داشته باشید که نه تنها فیلد مورد نظر بلکه تمام فیلدها به روز رسانی خواهند شد. برای پی بردن به نحوه ی اجرای پرس و جوی زیر بخش "به روز رسانی چندین آبجکت در یک عبارت" را مطالعه کنید:
[/p]

[code]
UPDATE books_publisher SET
    name = 'Apress Publishing'
WHERE id=52;
[/code]

[h3]id="136"[h3/]
‫واكشي آبجكت ها‬
[/h3]

[p]id="137"[p/]
برای ساختن برنامه های وب دانستن نحوه ی ساخت و به روز رسانی رکورد های پایگاه داده ضروری می باشد، ولی احتمال این وجود دارد که برنامه های وبی که خواهید ساخت نیاز به به اجرای پرس و جوهای بیشتری نیز داشته باشد. روش بازیابی رکوردها را نیز پیش تر مشاهده کردید:
[/p]

[code]
>>> Publisher.objects.all()
[<Publisher: Apress>, <Publisher: O'Reilly>]
[/code]

[p]id="138"[p/]
مدل کد فوق در SQL چیزی شبیه به کد زیر خواهد بود:
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher;
[/code]

[note]‫نكته‬[note/]
[p]id="139"[p/]
توجه داشته باشید که جنگو هنگامی که به دنبال داده ها می باشد از SELECT * استفاده نمی کند، در عوض لیست تمام فیلدها را به صورت واضح بازیابی می کند. در بعضی شرایط SELECT * می تواند کندتر باشد و (خیلی مهم است) لیست کردن فیلدها به طرز نزدیکی از مکتب پایتون (Zen of Python) پیروی کند: "صراحت بهتر از ابهام است".
[/p]
[/note]

[p]id="140"[p/]
اجازه دهید از نزدیک بخش های [چپ]Publisher.objects.all()[/چپ] را مورد بررسی قرار دهیم:
[/p]

[ul][ul/]
[li]id="141"[li/]
ابتدا، یک مدل داریم که Publisher تعریف شده است. چیز خاصی در اینجا وجود ندارد: هنگامی که شما می خواهید داده ای را جستجو کنید از یک مدل برای آن داده استفاده می کنید.
[/li]

[li]id="142"[li/]
و اما در مورد attribute متد objects. این attribute یک manager نامیده می شود. manager ها به تفصیل در فصل دهم توضیح داده شده اند. چیزی که برای الان باید بدانید این است که manager ها از تمامی عملکردهای سطح جدول در داده مراقبت می کنند که برای جستجوی داده ها بسیار پر اهمیت می باشند.
[/li]

[p]id="143"[p/]
تمام مدل ها به طور خود کار یک manager، objects دریافت می کنند؛ شما در هر زمان که بخواهید نمونه های مدل را جستجو کنید از استفاده خواهید کرد.
[/p]

[li]id="144"[li/]
در نهایت، [چپ]all()[/چپ] یک متد برای manager، objects می باشد که تمام ردیف های پایگاه داده را بر می گرداند. اگرچه این آبجکت شبیه به لیست می باشد، اما در واقع یک QuerySet می باشد (یک آبجکت که مجموعه مشخصی از ردیف های پایگاه داده می باشد.) در ادامه فصل تنها درباره آن ها همانند لیست ها بحث خواهیم کرد.
[/li]
[/ul]

[h4]id="145"[h4/]
فیلتر کردن داده
[/h4]

[p]id="146"[p/]
به طور طبیعی، کم پیش می اید که بخواهیم همه چیز را از پایگاه داده یکباره واکشی کنیم؛ در اغلب موارد، می خواهید با قسمتی از داده ها سر و کار داشته باشید. در API جنگو، شما می توانید داده ی خود را با استفاده از متد [چپ]filter()[/چپ] فیلتر کنید:
[/p]

[code]
>>> Publisher.objects.filter(name='Apress')
[<Publisher: Apress>]
[/code]

[p]id="147"[p/]
[چپ]filter()[/چپ] یک آرگومان به صورت کیورد در یافت می کند که معادل آن در SQL عبارت WHERE می باشد. معادل کد SQL مثال قبلی چیزی مانند کد زیر بود:
[/p]

[code]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';
[/code]

[p]id="148"[p/]
جهت محدود کردن بیشتر خروجی می توانید چندین آرگومان را به درون [چپ]filter()[/چپ] ارسال کنید:
[/p]

[code]
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress>]
[/code]

[p]id="149"[p/]
می توان ارسال چندین آرگومان به متد [چپ]filter()[/چپ] درون SQL مانند عبارت AND داست. در نتیجه، مثال فوق می تواند به شکل زیر یه کد SQL تبدیل شود:
[/p]

[code]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A.'
AND state_province = 'CA';
[/code]

[p]id="150"[p/]
توجه داشته باشید که به طور پیشفرض جستجو درون SQL با علامت = دقیقا یکسان بودن را بررسی می کند. نوع دیگر جستجو نیز در دسترس می باشد:
[/p]

[code]
>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress>]
[/code]

[p]id="151"[p/]
همانطور که مشاهده می کنید دو علامت (_) بین name و contains قرار دارد. مانند خود پایتون، جنگو از این خصوصیت برای اشاره به این که چیزی به صورت "magic" در حال اتفاق افتادن می باشد استفاده می کند (در اینجا قسمت __contains به عبارت LIKE در SQL تبدیل می شود.)
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name LIKE '%press%';
[/code]

[p]id="152"[p/]
انواع دیگر جستجو نیز در دسترس می باشد، از جمله icontains (عبارت LIKE که به حروف کوچک و بزرگ حساس می باشد)، starstwith، endswith و range (پرس و جوی BETWEEN در SQL).
[/p]

[h4]id="153"[h4/]
بازیابی آبجکت های تک
[/h4]

[p]id="154"[p/]
مثال های [چپ]filter()[/چپ] فوق همگی یک QuerySET را بر می گردانند، که می توان با آن ها مانند لیست ها کار کرد. گاهی اوقات بسیار مناسب می باشد که تنها یک تک آبجکت را از پایگاه داده واکشی کنیم. برای این منظور متد [چپ]get()[/چپ] در دسترس می باشد:
[/p]

[code]
>>> Publisher.objects.get(name="Apress")
<Publisher: Apress>
[/code]

[p]id="155"[p/]
بجای یک لیست (QuerySet) یک تک آبجکت برگشت داده شده است. به دلیل آنکه در صورتیکه نتیجه پرس و جو (query) چند آبجکت باشد موجب بروز خطای MultipleObjectsReturned خواهد شد:
[/p]

[code]
>>> Publisher.objects.get(country="U.S.A.")
Traceback (most recent call last):
    ...
MultipleObjectsReturned: get() returned more than one Publisher --
    it returned 2! Lookup parameters were {'country': 'U.S.A.'}
[/code]

[p]id="156"[p/]
همچنین در صورتیکه هیچ آبجکتی برگدانده نشود موجب بروز خطای DoesNotExist خواهد شد
[/p]

[code]
>>> Publisher.objects.get(name="Penguin")
Traceback (most recent call last):
    ...
DoesNotExist: Publisher matching query does not exist.
[/code]

[p]id="157"[p/]
خطای DoesNotExist یک attribute از کلاس مدل می باشد (Publisher.DoesNotExist). در برنامه های خود می توانید مانند زیر خطاها را کنترل کنید:
[/p]

[code]
try:
    p = Publisher.objects.get(name='Apress')
except Publisher.DoesNotExist:
    print "Apress isn't in the database yet."
else:
    print "Apress is in the database."
[/code]

[h4]id="158"[h4/]
مرتب سازی داده ها
[/h4]

[p]id="159"[p/]
همانطور که در مثال های قبلی مشاهده کردید، ممکن است متوجه این موضوع شده باشید که ترتیب قرار گیری آبجکت هایی که برگردانده می شوند به صورت تصادفی است. تا تکنون در مورد ترتیب چیدمان داده هایی که از پایگاده داده استخراج می شوند صحبت نشده است، ولی می توان خیلی ساده داده ها را با ترتیب چیدمان دلخواه بازیابی کرد.
[/p]


[p]id="160"[p/]
در برنامه های جنگو، ممکن است بخواهید نتیجه استخراج شده از پایگاه داده را بر اساس یکی از معیارها مرتب کنید (برای مثال بر اساس حروف الفبا). برای انجام این کار از متد [چپ]order_by()[/چپ] استفاده می شود:
[/p]

[code]
>>> Publisher.objects.order_by("name")
[<Publisher: Apress>, <Publisher: O'Reilly>]
[/code]

[p]id="161"[p/]
مثال فوق فرق چندانی با متد قبلی یعنی [چپ]all()[/چپ] ندارد، تنها فرق در این است که حالا SQL ترتیب تعیین شده را نیز لحاظ می کند:
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name;
[/code]

[p]id="162"[p/]
شما می توانید بر اساس هر فیلدی که مایلید خروجی را مرتب کنید:
[/p]

[code]
>>> Publisher.objects.order_by("address")
[<Publisher: O'Reilly>, <Publisher: Apress>]

>>> Publisher.objects.order_by("state_province")
[<Publisher: Apress>, <Publisher: O'Reilly>]
[/code]

[p]id="163"[p/]
برای مرتب کردن بر اساس چندین فیلد (در مواردی استفاده می شود که آرگومان اول درون هر دو فیلد یکی باشد، در آن زمان برای رفع ابهام از آرگومان دوم استفاده می شود.) مانند زیر:
[/p]

[code]
>>> Publisher.objects.order_by("state_province", "address")
 [<Publisher: Apress>, <Publisher: O'Reilly>]
[/code]

[p]id="164"[p/]
همچنین می توان ترتیب چیدمان را با استفاده از یک علامت (-) به صورت بر عکس انجام داد:
[/p]

[code]
>>> Publisher.objects.order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress>]
[/code]

[p]id="165"[p/]
در اغلب موارد شما همواره می خواهید در حالت پیشفرض خروجی داده های شما بر اساس یکی از فیلد های چیده شده باشد، در این صورت جنگو این امکان را فراهم می کند که به صورت پیشفرض درون مدل خود این کار انجام دهید، این امکان زمانی مفید واقع می شود که بخواهید به صورت مکرر از [چپ]order_by()[/چپ] استفاده کنید، در این صورت منطقی این است که روش زیر را انتخاب کنید:
[/p]

[code]
class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ['name']
[/code]

[p]id="166"[p/]
در مثال فوق، یک مفهوم جدید معرفی شده است: class Meta، کلاسی می باشد که درون کلاس Publisher تعریف شده است (این کلاس درون class Publisher به صورت داخل رفته indented قرار گرفته است). می توان از کلاس Meta روی هر مدل برای تعیین اختیارات مختلفی استفاده کرد. که در اینجا ما از اختیار مرتب کردن آن استفاده کرده ایم. این اختیار به جنگو می گوید که اگر به صورت واضح برای چیدمان داده از [چپ]order_by()[/چپ] استفاده نشده است، تمام آبجکت های Publisher هر زمان که با API پایگاه داده بازیابی شدند، باید بر اساس فیلد name مرتب شوند.
[/p]

[h4]id="167"[h4/]
جستجوی زنجیری
[/h4]

[p]id="168"[p/]
نحوه ی فیلتر کردن داده را مشاهده کردید، همچنین نحوه ی مرتب کردن آن ها را نیز مشاهده نمودید. اغلب، نیز می باشد هر دو مورد فوق را انجام دهید. در این موارد می توان به سادگی با استفاده از قابلیت جستجوی زنجیری هر دوی موارد فوق در یک خط انجام داد:
[/p]

[code]
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress>]
[/code]

[p]id="169"[p/]
همانطور که انتظار می رود، معادل کد فوق در SQL استفاده از یک WHERE و یک ORDER BY می باشد:
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A'
ORDER BY name DESC;
[/code]

[h4]id="170"[h4/]
تقسیم کردن داده
[/h4]

[p]id="171"[p/]
یکی دیگر از امکانات مورد نیاز، جستجوی تنها تعدادی از داده های مشخص از ردیف می باشد. تصور کنید تعداد صد ناشر درون پایگاه داده وجود دارد، در صورتیکه شما می خواهید تنها اولین ناشر را نمایش دهید. می توان برای انجام چنین کاری از خصوصیت تقسیم استاندار لیست پایتون استفاده کنید:
[/p]

[code]
>>> Publisher.objects.order_by('name')[0]
<Publisher: Apress>
[/code]

[p]id="172"[p/]
کد فوق به شکل زیر تبدیل می شود:
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name
LIMIT 1;
[/code]

[p]id="173"[p/]
به همین صورت، می توان زیر مجموعه ای از داده را نیز بازیابی کرد:
[/p]

[code]
>>> Publisher.objects.order_by('name')[0:2]
[/code]

[p]id="174"[p/]
مثال فوق دو آبجکت را بر می گرداند، و درون SQL به شکل زیر تبدیل خواهد شد:
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name
OFFSET 0 LIMIT 2;
[/code]

[p]id="175"[p/]
توجه داشته باشید که قسیم کردن به صورت منفی در اینجا پشتیبانی نمی شود:
[/p]

[code]
>>> Publisher.objects.order_by('name')[-1]
Traceback (most recent call last):
  ...
AssertionError: Negative indexing is not supported.
[/code]

[p]id="176"[p/]
با وجود این می توانید به راحتی محدودیت فوق را دور بزنید. تنها کافیست عبارت [چپ]order_by()[/چپ] را به صورت زیر تغییر دهید:
[/p]

[code]
>>> Publisher.objects.order_by('-name')[0]
[/code]

[h4]id="177"[h4/]
به روز رسانی چند آبجکت در یک عبارت
[/h4]

[p]id="178"[p/]
در بخش "درج و به روز رسانی داده" اشاره شد که متد [چپ]save()[/چپ] تمام ستون های یک ردیف را به روز رسانی می کند. بسته به برنامه ی شما، ممکن است بخواهید تنها یک قسمت از ستون ها را به روز رسانی کنید.
[/p]

[p]id="179"[p/]
به عنوان مثال، تصور کنید می خواهیم Apress را درون Publisher از 'Apress' به 'Apress Publishing' تغییر دهیم. با استفاده از [چپ]save()[/چپ] به این صورت عمل می توان کرد:
[/p]

[code]
>>> p = Publisher.objects.get(name='Apress')
>>> p.name = 'Apress Publishing'
>>> p.save()
[/code]

[p]id="180"[p/]
که درون SQL نیز به این شکل تبدیل خواهد شد:
[/p]

[code sql]
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
[/code]

[p]id="181"[p/]
(توجه داشته باشید که مثال فوق فرض را بر این گرفته است که Apress دارای id = 52 می باشد.)
[/p]

[p]id="182"[p/]
می توان در مثال فوق مشاهده نمود که متد [چپ]save()[/چپ] جنگو نه تنها ستون name را بلکه ارزش تمام ستون ها را به روز رسانی می کند. منطقی تر و بهتر آن است که تنها ستون مورد نظر تغییر کند. برای انجام چنین کاری می توان از متد [چپ]update()[/چپ] موجود در آبجکت های QuerySet استفاده مانند زیر استفاده کرد:
[/p]

[code]
>>> Publisher.objects.filter(id=52).update(name='Apress Publishing')
[/code]

[p]id="183"[p/]
کد فوق درون SQL به این شکل تبدیل می شود:
[/p]

[code]
UPDATE books_publisher
SET name = 'Apress Publishing'
WHERE id = 52;
[/code]

[p]id="184"[p/]
متد [چپ]update()[/چپ] بر روی هر QuerySet ای کار می کند، بدین معنی که می توان چندین رکورد را نیز ویرایش کرد. در مثال زیر نحوه تغییر country درون هر رکورد Publisher از 'U.S.A' به USA نشان داده شده است.
[/p]

[code]
>>> Publisher.objects.all().update(country='USA')
2
[/code]

[p]id="185"[p/]
متد [چپ]update()[/چپ] یک integer بر می گرداند که تعداد رکوردهای تغییر داده شده می باشد، در مثال فوق 2 رکورد تغییر داده شده اند.
[/p]

[h4]id="186"[h4/]
حذف کردن آبجکت ها
[/h4]

[p]id="187"[p/]
برای حذف کردن یک آبجکت از پایگاه داده، به سادگی متد [چپ]delete()[/چپ] را می توان فراخوانی کرد:
[/p]

[code]
>>> p = Publisher.objects.get(name="O'Reilly")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>]
[/code]

[p]id="188"[p/]
همچنین می توان چندین آبجکت را نیز با فراخوانی متد [چپ]delete()[/چپ] از هر QuerySet حذف کرد. این حالت مانند متد [چپ]update()[/چپ] که در بخش گذشته نشان داده شد می باشد:
[/p]

[code]
>>> Publisher.objects.filter(country='USA').delete()
>>> Publisher.objects.all().delete()
>>> Publisher.objects.all()
[]
[/code]

[p]id="189"[p/]
هنگام حذف کردن داده ها مراقب باشید! برای احتیاط از حذف شدن تمام داده های موجود در یک جدول مشخص، در صورتیکه می خواهید هر آنچه که درون جدول می باشد را حذف کنید، می توان از متد [چپ]all()[/چپ] استفاده کرد. به عنوان مثال کد زیر کار نخواهد کرد:
[/p]

[code]
>>> Publisher.objects.delete()
Traceback (most recent call last):
  File "<console>", line 1, in <module>
AttributeError: 'Manager' object has no attribute 'delete'
[/code]

[p]id="190"[p/]
ولی اگر متد [چپ]all()[/چپ] را اضافه کنید کار خواهد کرد:
[/p]

[code]
>>> Publisher.objects.all().delete()
[/code]

[p]id="191"[p/]
در صورتیکه می خواهید تنها بخشی از داده را حذف کنید، نیازی به متد all() نمی باشد:
[/p]

[code]
>>> Publisher.objects.filter(country='USA').delete()
[/code]

[h3]id="192"[h3/]
گام بعدی
[/h3]

[p]id="193"[p/]
بعد از خواندن این فصل، شما دانش کافی از مدل های جنگو را کسب کرده اید و قادر خواهید بود برنامه های پایگاه داده ی اولیه را بنویسید. فصل دهم اطلاعات بیشتر و پیشرفته تری در خصوص لایه ی پایگاه داده جنگو  در اخیار می گذارد.
[/p]

[p]id="194"[p/]
هنگامی که شما مدل های خود را تعریف کردید، گام بعدی پر کردن پایگاه داده با داده ها می باشد. ممکن است داده ی شما از نوع ارث بری باشد، که در فصل هجدهم در مورد آن صحبت شده است. ممکن است بخواهید کاربران را برای تهیه ی داده سهیم کنید که در این مورد نیز در فصل هفتم توضیح داده شده است.
[/p]

[p]id="195"[p/]
ولی در برخی موارد، ممکن است نیزا به وارد کردن داده به صورت دستی باشد، در این مورد ممکن است مفید باشد که یک رابط تحت وب برای وارد کردن و مدیریت داده ها داشته باشید. فصل بعدی رابط مدیر جنگو را پوشش می دهد که دلیل وجود آن دقیقا همین موضوع می باشد.
[/p]