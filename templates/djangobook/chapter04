[h2]«هد/»
Template ها در جنگو 
[/h2]

[p]id="1"[p/]
در فصل گذشته دیدیم که کد HTML را می توانیم به صورت یک متن به طور مستقیم درون view بگنجانیم:
[/p]

[code]
def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
[/code]

[ul][ul/]
[li]id="2"[li/]
یکی از معایب روش بالا این است که برای هرگونه اعمال تغییر در طراحی صفحه نیازمند تغییر در کد پایتون می باشیم. می دانیم که طراحی سایت نیازمند تغییرات متعددی است در نتیجه استفاده از این روش موجب تغییر به مراتب بیشتر کد پایتون می باشد. بنابراین مناسب تر آن است که طراحی صفحه و ایجاد تغییرات در آن، نیازی به اصلاح و تغییر کد پایتون نداشته باشد.
[/li]

[li]id="3"[li/]
نوشتن کد پایتون و طراحی HTML دو موضوع متفاوت از یکدیگر بوده و نظم و قانون مربوط به خود را دارند، و بیشتر محیط های توسعه ی وب حرفه ای این مسئولیت ها را جدا کرده و به افراد جدا (حتی به بخش و حوزه ی جدا) واگذار می کنند. طراحان و کد نویسان HTML/CSS نباید نیاز به ویرایش کد پایتون برای کار خود داشته باشند.
[/li]

[li]id="4"[li/]
اگر طراحان بتوانند بر روی کدهای html در همان زمان که برنامه نویسان در حال کار با کدهای پایتون هستند، کار کنند. بهترین بهره وری از کار را خواهیم داشت زیرا دیگر نیازی نیست که یک فرد منتظر تمام کردن کد توسط فردی دیگر باشد چرا که در یک فایل کد HTML و کد پایتون هر دو به صورت جداگانه وجود دارد.
[/li]
[/ul]

[p]id="5"[p/]
این حالت را (که کد HTML به طور مستقیم درون view قرار بگیرد) به اصطلاح hard-code می نامند، بدین معنا که کد HTML به صورت غیر مستقل داخل کد پایتون قرار دارد و تغییر آن کار ساده ای نخواهد بود.
[/p]

[p]id="6"[p/]
اگرچه تکنیک فوق برای توضیح و یا شرح نحوه ی کارکرد view در فصل قبلی مناسب به نظر می آید، اما به دلایل ذکر شده در بالا این ایده ی خوبی نیست که کد HTML به صورت hard-code به طور مستقیم درون view قرار گیرد.
[/p]

[p]id="7"[p/]
همانطور که ذکر کردیم جدا کردن طراحی صفحه از کد پایتون مربوط به آن بسیار واضح و منطقی است. با استفاده از سیستم template جنگو می توانیم کدهای مربوط به HTML را از کد پایتون جداسازی کنیم، که در این فصل به این موضوع خواهیم پرداخت.
[/p]

[h3]id="8"«هس/»
قواعد Template System
[/h3]

[p]id="9"[p/]
template جنگو یک رشته ای از متن می باشد که برای جدا کردن نمایش یک سند از داده ی خود در نظر گرفته شده است. قالب حفره ها و تکه کدهای (تگ های template) مختلفی را تعریف می کند که نحوه ای که سند باید نمایش داده شود را تنظیم می کند. به طور معمول template ها برای تولید HTML استفاده می شوند، اما template های جنگو به همان اندازه در تولید هر فرمت متنی توانا هستند.
[/p]

[p]id="10"[p/]
بیایید با یک مثال ساده شروع کرده و آن را مورد بررسی قرار دهیم:
[/p]

[code html]
<html>
<head><title>Ordering notice</title></head>

<body>

<h1>Ordering notice</h1>

<p>Dear {{ person_name }},</p>

<p>Thanks for placing an order from {{ company }}. It's scheduled to
ship on {{ ship_date|date:"F j, Y" }}.</p>

<p>Here are the items you've ordered:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Your warranty information will be included in the packaging.</p>
{% else %}
    <p>You didn't order a warranty, so you're on your own when
    the products inevitably stop working.</p>
{% endif %}

<p>Sincerely,<br />{{ company }}</p>

</body>
</html>
[/code]

[p]id="11"[p/]
template فوق یک HTML بنیادی با برخی متغیرها و تگ های template استفاده شده در آن می باشد. بیایید template فوق را مورد بررسی قرار دهیم.
[/p]

[ul][ul/]
[li]id="12"[li/]
هر متنی که داخل دو آکولاد قرار گرفته باشد (مانند {{ person_name }}) یک متغیر است. این بدین معنی می باشد که "مقدار ارزش متغیر با نام داده شده را درج کند" به عبارت دیگر اگر (person_name) داخل آکولاد قرار نگیرد خروجی Dear person_name را درج خواهد کرد و نام شخص را به ما نشان نمی دهد. (چطور ارزش متغیرها را می توان تعیین کرد؟ در این فصل خواهید فهمید.)
[/li]

[li]id="13"[li/]
هر متنی که داخل یک آکولاد و علامت درصد قرار بگیرد (مانند {% if ordered_warranty %}) یک تگ template می باشد. تعریف یک تگ بسیار وسیع می باشد: تگ به template می گوید که "کاری را انجام بده".
[/li]

[p]id="14"[p/]
مثال template فوق حاوی یک تگ [چپ]for ({% for item in item_list %})[/چپ] و یک تگ [چپ]if ({% if ordered_warranty %})[/چپ] می باشد. 
[/p]

[p]id="15"[p/]
تگ for بسیار شبیه به عبارت for در پایتون می باشد، که به ما اجازه می دهد درون سرتاسر آیتم های یک لیست به ترتیب بگردید و یا تغییراتی را بر روی همه یا یک سری از آیتم ها اعمال کنیم. تگ if همانطور که انتظار آن می رود، به صورت یک عبارت if منطقی عمل می کند. در این مورد خاص، تگ مورد نظر بررسی می کند که آیا ارزش متغیر ordered_warranty ،True می باشد یا خیر. اگر بدین صورت بود یعنی اگر مقدار آن True بود، سیستم template جنگو هر آنچه که بین {% if ordered_warranty %} و {% else %} باشد را نمایش خواهد داد، در غیر اینصورت سیستم template جنگو هر آنچه را که بین {% else %} و {% endif %} باشد را نمایش خواهد داد. توجه داشته باشید که تک {% else %} کاملا اختیاری می باشد.
[/p]

[li]id="16"[li/]
نهایتا، پاراگراف دوم template فوق حاوی یک مثال از filter می باشد، که مناسب ترین روش برای تغییر قالب بندی (formatting) یک متغیر می باشد. در این مثال، {{ ship_date|date:"F j, Y" }}، متغیر ship_date به فیلتر date ارسال شده، و آرگومان "F j, Y" نیز به فیلتر date داده شده است. فیلتر date تاریخ را بر اساس آرگومان تغیین شده قالب بندی می کند. فیلترها با استفاده از علامت (|) مربوط می شوند، همانند کاربرد آن در یونیکس.
[/li]
[/ul]

[p]id="17"[p/]
هر قالب جنگو به چندین تگ و فیلتر داخلی (built-in) دسترسی دارد، تعدادی از آن ها در ادامه فصل های کتاب مورد بحث قرار خواهند گرفت. همچنین این امکان وجود دارد که فیلتر و تگ برای خودتان ایجاد کنید؛ که در فصل نهم این کتاب بیان خواهد شد.
[/p]

[h3]id="18"«هس/»
استفاده از template جنگو
[/h3]

[p]id="19"[p/]
بیایید وارد بحث template جنگو شویم، تا شما نحوه ی کارکرد آن را مشاهده کنید، ولی هنوز نمی خواهیم قالب جنگو را با view هایی که در فصل گذشته ساخته شد به هم مرتبط کنیم. هدف در اینجا این است که با نحوه ی کار template جنگو، مستقل از دیگر بخش ها آشنا شوید. (به عبارت دیگر: به طور معمول شما template جنگو را همراه با یک view استفاده خواهید کرد، ولی می خواهیم این موضوع را روشن کنیم که template جنگو تنها کتابخانه ی پایتون می باشد که شما می توانید آن را در هرجایی استفاده کنید، نه فقط در view های جنگو.)
[/p]

[p]id="20"[p/]
در اینجا ابتدایی ترین راه که می تونید  قالب جنگو را در کد پایتون استفاده کنید آمده است:
[/p]

[p]id="21"[p/]
ساختن آبجکت Template از طریق ایجاد کد قالب به صورت رشته.
[/p]

[p]id="22"[p/]
فراخوانی متد [چپ]render()[/چپ] از آبجکت Template با دادن یک مجموعه ای از متغیرها (the context). این متد قالب را به صورت رشته ی کامل با تمام متغیرها و تگ های قالب بر می گرداند.
[/p]

[p]id="23"[p/]
به کد زیر توجه کنید:
[/p]

[code]
>>> from django import template
>>> t = template.Template('My name is {{ name }}.')
>>> c = template.Context({'name': 'Adrian'})
>>> print t.render(c)
My name is Adrian.
>>> c = template.Context({'name': 'Fred'})
>>> print t.render(c)
My name is Fred.
[/code]

[p]id="24"[p/]
در بخش بعدی جزئیات هر خط از کد بالا شرح داده خواهد شد.
[/p]

[h4]id="25"[h4/]
ساختن آبجکت های template
[/h4]

[p]id="26"[p/]
ساده ترین راه برای ساختن آبجکت Template به طور مستقیم به عنوان نمونه ذکر کردن آن می باشد. کلاس Template درون ماژول django.template می باشد و سازنده ی (cunstructor) آن یک آرگومان دریافت می کند که کد خام template می باشد. بیایید نمونه آن را درون interactive interpreter پایتون مشاهده کنیم.
[/p]

[p]id="27"[p/]
درون دایرکتوری mysite ساخته شده توسط دستور django-admin.py startproject (بیان شده در فصل دوم)، دستور python manage.py shell را تایپ کرده و interactive interpreter را باز کنید.
[/p]

[note]
خط فرمان ویژه ی پایتون
[note/]
[p]id="28"[p/]
در صورتیکه در گذشته از پایتون استفاده کرده باشید، ممکن است متعجب شوید که چرا بجای فرمان python، از فرمان python manage.py shell استفاده شده است. هر دو فرمان باعث باز شدن interactive interpreter خواهد شد، با این تفاوت که دستور manage.py shell قبل از آغاز شدن interpreter، به جنگو اعلام می کند که از کدام فایل تنظیمات استفاده کند. بسیاری از قسمت ها در جنگو، حاوی سیستم template می باشد، که شما قادر به استفاده از آن ها نخواهید بود مگر آنکه فریم ورک بداند از کدام تنظیمات استفاده کند.
[/p]

[p]id="29"[p/]
اگر در مورد نحوه ی انجام کار فوق کنجکاو هستید، در اینجا توضیح نحوه ی عملکرد آن در پشت صحنه، وجود دارد. جنگو به دنبال یک متغیر محیطی با نام DJANGO_SETTINGS_MODULE می گردد که باید در مسیر import فایل settings.py شما قرار گرفته باشد. به عنوان مثال، با فرض اینکه mysite مسیر پایتون شما می باشد، DJANGO_SETTINGS_MODULE ممکن است در 'mysite.settings'، قرار گرفته باشد.
[/p]

[p]id="30"[p/]
هنگامی که شما فرمان python manage.py shell را اجرا می کنید، فرمان مذکور به DJANGO_SETTINGS_MODULE توجه می کند. شما را تشویق می کنیم برای به حداقل رساندن پیچیدگی و تنظیماتی که باید انجام دهید از python manage.py shell در این مثال ها استفاده کنید 
[/p]

[p]id="31"[p/]
هنگامی که با جنگو بیشتر آشنا شوید، احتمالا استفاده از manage.py shell را کنار گذاشته و خودتان به صورت دستی DJANGO_SETTINGS_MODULE را در .bash_profile یا محیط های دیگر تنظیم خواهید داد.
[/p]
[/note]

[p]id="32"[p/]
اجازه دهید با اصول اولیه سیستم template جنگو آشنا شویم:
[/p]

[code]
>>> from django.template import Template
>>> t = Template('My name is {{ name }}.')
>>> print t
[/code]

[p]id="33"[p/]
با وارد کردن کد فوق، چیزی شبیه به این مشاهده خواهید کرد:
[/p]

[pre][pre/]
<django.template.Template object at 0xb7d5f24c>
[/pre]

[p]id="34"[p/]
عبارت 0xb7d5f24c هویت آبجکت پایتون می باشد که در هر زمان متفاوت می باشد واز حیطه بحث ما خارج می باشد.
[/p]

[p]id="35"[p/]
هنگامی که یک آبجکت Template ایجاد می کنید، سیستم template جنگو کد template را به صورت داخلی کامپایل می کند، و شکل بهینه آن برای ارائه دادن (rendering) آماده می شود، اما در صورتیکه کد template شما دارای اشکال باشد، فراخوانی [چپ]Template()[/چپ] موجب بروز خطا خواهد شد: 
[/p]

[code]
>>> from django.template import Template
>>> t = Template('{% notatag %}')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  ...
django.template.TemplateSyntaxError: Invalid block tag: 'notatag'
[/code]

[p]id="36"[p/]
در موارد زیر خطای TemplateSyntaxError رخ خواهد داد:
[/p]

[ul][ul/]
[li]id="37"[li/]
تگ های نا معتبر
[/li]

[li]id="38"[li/]
آرگومان های نا معتبر درون تگ های معتبر
[/li]

[li]id="39"[li/]
فیلترهای نا معتبر
[/li]

[li]id="40"[li/]
آرگومان های نا معتبر درون فیلترهای معتبر
[/li]

[li]id="41"[li/]
کد template نا معتبر
[/li]

[li]id="42"[li/]
تگ های بسته نشده (تگ های for باید بسته شوند)
[/li]
[/ul]

[h4]id="43"[h4/]
ارائه دادن (rendering) یک Template
[/h4]

[p]id="44"[p/]
هنگامی که شما یک آبجکت Template دارید، می توانید از طریق یک context به آن داده ارسال کنید. context مجموعه ای از نام متغیرهای template و ارزش های آن ها می باشد. Template با استفاده از context متغیرهای خودش را با ارزش مورد نظر جایگزین کرده و تگ ها را نیز اجرا می کند.
[/p]

[p]id="45"[p/]
context با کلاس Context در جنگو نشان داده می شود، که درون ماژول django.template قرار دارد. سازنده ی آن یک آرگومان اختیاری دریافت می کند: یک دیکشنری نام های متغیر و ارزش های آن. برای پر کردن template متد [چپ]render()[/چپ] آبجکت Template را با context فراخوانی می کنیم:
[/p]

[code]
>>> from django.template import Context, Template
>>> t = Template('My name is {{ name }}.')
>>> c = Context({'name': 'Stephane'})
>>> t.render(c)
u'My name is Stephane.'
[/code]

[p]id="46"[p/]
نکته ای که باید در اینجا اشاره کنیم این است که مقدار برگشتی (t.render(c یک رشته ی معمولی پایتون نمی باشد، بلکه یک آبجکت یونیکد است. که با نمایش حرف u در ابتدای آن نشان داده می شود. جنگو در سراسر فریم ورک به جای رشته ی معمولی پایتون از آبجکت های یونیکد استفاده می کند. پشتیبانی یونیکد جنگو نسبتااز طیف گسترده ای از حروف برای برنامه های شما بدون زحمت و دردسر پشتیبانی می کند.
[/p]

[note]
دیکشنری ها و context ها
[note/]
[p]id="47"[p/]
دیکشنری پایتون یک رابطه ی بین کلید ها و ارزش های متغیر می باشد. یک context همانند یک دیکشنری می باشد، با این تفاوت که حالت تابعی به خود گرفته است و در فصل نهم مورد بحث قرار خواهد گرفت.
[/p]
[/note]

[p]id="48"[p/]
نام متغیرها باید با حروف الفبای انگلیسی شروع شوند (A-Z or a-z) و می توانند حاوی حروف الفبا، عدد، خط تیره (_) و نقطه باشند (نقطه ها مورد ویژه ای هستند که بعدا راجع به آن صحبت خواهیم کرد.)، همچنین نام متغیرها به حروف کوچک و بزرگ حساس می باشند.
[/p]

[p]id="49"[p/]
در اینجا یک مثال از کامپایل template و rendering آن شبیه به مثالی که در ابتدای فصل مشاهده کردید وجود دارد، 
[/p]

[code]
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
...
... <p>Thanks for placing an order from {{ company }}. It's scheduled to
... ship on {{ ship_date|date:"F j, Y" }}.</p>
...
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% else %}
... <p>You didn't order a warranty, so you're on your own when
... the products inevitably stop working.</p>
... {% endif %}
...
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
...     'company': 'Outdoor Equipment',
...     'ship_date': datetime.date(2009, 4, 2),
...     'ordered_warranty': False})
>>> t.render(c)
u"<p>Dear John Smith,</p>\n\n<p>Thanks for placing an order from Outdoor
Equipment. It's scheduled to\nship on April 2, 2009.</p>\n\n\n<p>You
didn't order a warranty, so you're on your own when\nthe products
inevitably stop working.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment
</p>"
[/code]

[p]id="50"[p/]
اجازه دهید کد فوق را مورد بررسی قرار دهیم:
[/p]

[ul][ul/]
[li]id="51"[li/]
در ابتدا کلاس های Template و Context از ماژول django.template به درون برنامه import شده اند.
[/li]

[li]id="52"[li/]
متن خام template درون متغیر raw_template ذخیره شده است. باید توجه داشته باشیم که در رشته های معمولی تنها می توان از یک خط استفاده کرد. واگر بخواهیم از رشته های چند خطی استفاده کنیم بایستی از علامت (" " ") برای رشته ی مورد نظر استفاده کنیم.
[/li]

[li]id="53"[li/]
در قدم بعدی، یک آبجکت template به نام t ساخته شده و رشته ی raw_template به سازنده ی آن ارسال شده است.
[/li]

[li]id="54"[li/]
ماژول datetime از کتابخانه ی استاندارد پایتون درون برنامه import شده است، چرا که در ادامه ی کار مورد استفاده قرار خواهد گرفت.
[/li]

[li]id="55"[li/]
یک آبجکت context به نام c ساخته شده است، سازنده ی context یک دیکشنری پایتون دریافت می کند که نام های متغیرها را با ارزش ها مرتبط می سازد. برای مثال در اینجا person_name به 'John Smith'، company به 'Outdoor Equipment'، و غیره مرتبط شده است.
[/li]

[li]id="56"[li/]
در نهایت، متد [چپ]render()[/چپ] از آبجکت template فراخوانی شده، و context به آن ارسال شده است. این متد یک template قابل ارائه را بر می گرداند، بدین معنی که تمام متغیرها با ارزش و مقدار واقعی جایگزین شده و تمام تگ های template اجرا شده اند.
[/li]

[p]id="57"[p/]
توجه داشته باشید که پاراگراف "You didn't order a warranty" نمایش داده می شود چرا که متغیر ordered_warranty به صورت False ارزیابی شده است. همچنین توجه کنید تاریخ April 2, 2009 به حالت آن قالب بندی که برای آن مشخص شده است نمایش داده شده است (F j, Y). 
[/p]

[p]id="58"[p/]
در صورتیکه تازه با زبان برنامه نویسی پایتون آشنا شده باشید، ممکن است تعجب کنید که رشته ی خروجی به رفتن به خط بعد حرف (n\) را نمایش می دهد. دلیل زیرکی interactive interpreter پایتون می باشد: فراخوانی (t.render(c یک رشته بر می گرداند، و interactive interpreter به صورت پیشفرض به جای شکل چاپی رشته شکل نمایشی آن را نشان می دهد. در صورتیکه می خواهید رشته با حالت چاپی نمایش داده شود، یعنی بجای حرف (n\) رشته به خط بعد برود، می توانید از عبارت print استفاده کنید: (print t.render(c.
[/p]
[/ul]

[p]id="59"[p/]
مسائل فوق اصول استفاده از template system جنگو می باشد: نوشتن یک رشته ی template، ساختن آبجکت Template، ساختن Context و فراخوانی متد [چپ]render()[/چپ].
[/p]

[h4]id="60"[h4/]
Context های چندگانه در یک Template
[/h4]

[p]id="61"[p/]
با یک آبجکت Template می توانید چندین context را ارائه دهید. برای مثال:
[/p]

[code]
>>> from django.template import Template, Context
>>> t = Template('Hello, {{ name }}')
>>> print t.render(Context({'name': 'John'}))
Hello, John
>>> print t.render(Context({'name': 'Julie'}))
Hello, Julie
>>> print t.render(Context({'name': 'Pat'}))
Hello, Pat
[/code]

[p]id="62"[p/]
هر گاه مانند مثال فوق از template همسان برای چندین context استفاده می کنید ، بسیار بهینه تر می باشد اگر یک مرتبه یک آبجکت Template ساخته و سپس متد [چپ]render()[/چپ] را برای چند بار فراخوانی کنید:
[/p]

[code]
# Bad
for name in ('John', 'Julie', 'Pat'):
    t = Template('Hello, {{ name }}')
    print t.render(Context({'name': name}))

# Good
t = Template('Hello, {{ name }}')
for name in ('John', 'Julie', 'Pat'):
    print t.render(Context({'name': name}))
[/code]

[p]id="63"[p/]
تجزیه ی template جنگو کاملا سریع می باشد. در پشت صحنه بیشترین تجزیه در جنگو از طریق فراخوانی یک regular expression می باشد. این متضاد با موتور های template ای می باشد که پایه اساس آنها XML باشد، چرا که بسیار کند تر از موتور template جنگو می باشند.
[/p]

[h4]id="64"[h4/]
متغیرهای دیگر قابل ارسال به Context
[/h4]

[p]id="65"[p/]
مثال های آورده شده تاکنون، یک مقدار ساده را به context ها ارسال کرده اند که به غیر مثال datetime.date غالبا رشته بوده اند. در صورتی که template system جنگو با ظرافت خاصی تعداد بیشتری از داده های با ساختار پیچیده را مانند لیست ها، دیکشنری ها و آبجکت های ساخته شده را نیز کنترل می کند.
[/p]

[p]id="66"[p/]
کلید گذشتن از داده های با ساختار پیچیده در template های جنگو حرف نقطه ( . ) می باشد، با استفاده از نقطه می توان به کلیدهای دیکشنری، attribute ها، متد ها و اندیس های یک آبجکت نیز دسترسی داشت.
[/p]

[p]id="67"[p/]
بهترین توضیح استفاده از چند مثال می باشد. برای نمونه، فرض کنید شما یک دیکشنری پایتون را به یک template ارسال کرده اید. برای دسترسی به مقادیر دیکشنری مورد نظر با کلید دیکشنری از  یک نقطه استفاده کنید:
[/p]

[code]
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'Sally is 43 years old.'
[/code]

[p]id="68"[p/]
به طور مشابه، نقطه ها همچنین اجازه می دهند به attribute های آبجکت نیز دسترسی پیدا کنید. برای مثال، آبجکت datetime.date پایتون دارای attribute های year، month و day می باشد، می توان با استفاده از یک نقطه به attribute های آن در template جنگو دسترسی پیدا کرد:
[/p]

[code]
>>> from django.template import Template, Context
>>> import datetime
>>> d = datetime.date(1993, 5, 2)
>>> d.year
1993
>>> d.month
5
>>> d.day
2
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
u'The month is 5 and the year is 1993.'
[/code]

[p]id="69"[p/]
در مثال زیر از یک کلاس ساخته شده استفاده شده است که نشان می دهد از نقطه ها می توان جهت دسترسی به آبجکت های دلخواه نیز استفاده کرد:
[/p]

[code]
>>> from django.template import Template, Context
>>> class Person(object):
...     def __init__(self, first_name, last_name):
...         self.first_name, self.last_name = first_name, last_name
>>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
>>> c = Context({'person': Person('John', 'Smith')})
>>> t.render(c)
u'Hello, John Smith.'
[/code]

[p]id="70"[p/]
از طریق نقطه ها همچنین می توانند به متدهای درون یک آبجکت نیز دسترسی پیدا کرد. برای مثال هر رشته ی پایتون، دارای متدهای [چپ]upper()[/چپ] و [چپ]isdigit()[/چپ] می باشد، و می توان آن ها را در template جنگو فراخوانی و استفاده کرد:
[/p]

[code]
>>> from django.template import Template, Context
>>> t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
>>> t.render(Context({'var': 'hello'}))
u'hello -- HELLO -- False'
>>> t.render(Context({'var': '123'}))
u'123 -- 123 -- True'
[/code]

[p]id="71"[p/]
توجه داشته باشید که پرانتزهای مربوط به متدها را در template نباید به کار برد. همچنین نمی توان به متدها آرگومان ارسال کرد؛ شما می توانید تنها متدهایی را فراخوانی کنید که هیچ آرگومانی دریافت نمی کنند. (کمی بعد در این فصل این فلسفه توضیح داده خواهد شد.) 
[/p]

[p]id="72"[p/]
همچنین نقطه ها برای دسترسی به اندیس های لیست نیز استفاده می شوند، برای مثال:
[/p]

[code]
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
u'Item 2 is carrots.'
[/code]

[p]id="73"[p/]
اندیس های منفی لیست را در template نمی توان استفاده کرد، برای مثال، متغیر {{ items.-1 }} موجب بروز خطای TemplateSyntaxError خواهد شد.
[/p]

[note]
لیست های پایتون
[note/]
[p]id="74"[p/]
یادآوری: لیست های پایتون با اندیس صفر شروع می شوند، بدین معنی که اولین اندیس صفر، دومین اندیس یک و به همین ترتیب ادامه خواهد داشت.
[/p]
[/note]

[p]id="75"[p/]
کاربرد نقطه ها در template را می توان بدین شکل خلاصه کرد: هنگامی که template system با یک نقطه در مقابل نام یک متغیر برخورد می کند، به دنبال مسائل زیر جستجو خواهد کرد:
[/p]

[ul][ul/]
[li]id="76"[li/]
دیکشنری (مانند [چپ]foo["bar"][/چپ])
[/li]

[li]id="77"[li/]
attribute (مانند foo.bar)
[/li]

[li]id="78"[li/]
فراخوانی متد (مانند [چپ]foo.bar()[/چپ])
[/li]

[li]id="79"[li/]
اندیس لیست (مانند [چپ]foo[2][/چپ])
[/li]
[/ul]

[p]id="80"[p/]
نقطه ها می توانند به صورت تودرتو نیز استفاده شوند. به عنوان نمونه،مثال زیر از عبارت {{ person.name.upper }} استفاده کرده است که ابتدا درون یک دیکشنری به جستجو می پردازد ([چپ]person['name'][/چپ]) سپس یک متد را فراخوانی می کند ([چپ]upper()[/چپ]):
[/p]

[code]
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'SALLY is 43 years old.'
[/code]

[h3]id="81"«هس/»
فراخوانی متد و رفتار آن
[/h3]

[p]id="82"[p/]
فراخوانی متد کمی پیچیده تر از دیگر انواع جستجو می باشد. در زیر مواردی که باید به خاطر داشته باشیم بیان شده است:
[/p]

[ul][ul/]

[li]id="83"[li/]
اگر در طی فراخوانی متد، یک متد خطایی تولید کرد، آن خطا اعمال خواهد شد مگر آنکه کلاس آن خطا دارای attribute ای به نام silent‑variable‑failure با مقدار True باشد. در صورتیکه کلاس خطا دارای attribute مورد نظر باشد، متغیر درون template مقدار خالی را نشان خواهد داد، به عنوان مثال:
[/li]

[code]
>>> t = Template("My name is {{ person.first_name }}.")
>>> class PersonClass3:
...     def first_name(self):
...         raise AssertionError, "foo"
>>> p = PersonClass3()
>>> t.render(Context({"person": p}))
Traceback (most recent call last):
...
AssertionError: foo

>>> class SilentAssertionError(AssertionError):
...     silent_variable_failure = True
>>> class PersonClass4:
...     def first_name(self):
...         raise SilentAssertionError
>>> p = PersonClass4()
>>> t.render(Context({"person": p}))
u'My name is .'
[/code]

[li]id="84"[li/]
فراخوانی متد تنها زمانی کار خواهد کرد که متد مورد نظر هیچ آرگومان ضروری نداشته باشد. در غیر اینصورت system در پی نوع دیگر بعدی (اندیس لیست) خواهد رفت.
[/li]

[li]id="85"[li/]
بدیهی است که برخی از متدها دارای اثرات زیان آور، و حتی می توانند یک حفره ی امنیتی باشند، و اجازه ی دسترسی template system به آن متدها کاری ناشیانه می باشد.
[/li]

[p]id="86"[p/]
به عنوان نمونه، فرض کنید شما یک آبجکت BankAccount دارید که دارای یک متد [چپ]delete()[/چپ] می باشد. اگر یک template حاوی چیزی شبیه به این باشد {{ account.delete }}، در صورتیکه account آبجکت BankAccount باشد، هنگام ارائه template آبجکت مورد نظر حذف خواهد شد!
[/p]

[p]id="87"[p/]
برای جلوگیری از این موضوع، باید بدین شکل عمل کرد:
[/p]

[code]
def delete(self):
    # Delete the account
delete.alters_data = True
[/code]

[p]id="88"[p/]
template system هر متدی که با روش فوق مشخص شده باشد را اجرا نخواهد کرد. در مثال فوق، اگر یک template حاوی {{ account.delete }} باشد و متد [چپ]delete()[/چپ] دارای alter_data=True باشد، در این صورت متد [چپ]delete()[/چپ] هنگام ارائه ی template اجرا نخواهد شد و بجای آن، بی صدا رد خواهد شد.
[/p]
[/ul]

[h4]id="89"[h4/]
نحوه ی کنترل متغیرهای نا معتبر
[/h4]

[p]id="90"[p/]
به صورت پیشفرض، اگر یک متغیر وجود نداشته باشد، template system آن را به صورت یک رشته ی خالی ارائه می دهد. به عنوان مثال:
[/p]

[code]
>>> from django.template import Template, Context
>>> t = Template('Your name is {{ name }}.')
>>> t.render(Context())
u'Your name is .'
>>> t.render(Context({'var': 'hello'}))
u'Your name is .'
>>> t.render(Context({'NAME': 'hello'}))
u'Your name is .'
>>> t.render(Context({'Name': 'hello'}))
u'Your name is .'
[/code]

[p]id="91"[p/]
سیستم template بجای بروز خطا، آرام از کنار آن می گذرد. در صورت بروز خطا در این مورد برنامه به دلیل مچ نبودن حروف بزرگ و کوچک از روال عادی خارج می شود، در دنیای واقعی، برای یک وب سایت غیر قابل قبول است که به دلیل یک خطای نوشتاری در یک template کوچک همه چیز غیر قابل دسترس شده و برنامه متوقف شود.
[/p]

[h4]id="92"[h4/]
بازی با آبجکت های Context
[/h4]

[p]id="93"[p/]
در اغلب مواقع، آبجکت های Context را با ارسال داده ی دیکشنری به آن تعریف می کنند. می توان ایتم های آبجکت Context را بعد از تعریف نیز مانند دیکشنری استاندارد پایتون حذف یا اضافه کرد:
[/p]

[code]
>>> from django.template import Context
>>> c = Context({"foo": "bar"})
>>> c['foo']
'bar'
>>> del c['foo']
>>> c['foo']
Traceback (most recent call last):
  ...
KeyError: 'foo'
>>> c['newvariable'] = 'hello'
>>> c['newvariable']
'hello'
[/code]

[h3]id="94"«هس/»
تگ ها و فیلترهای اولیه ی Template
[/h3]

[p]id="95"[p/]
همانطور که گفته شد، سیستم template جنگو تعدادی تگ ها و فیلترهای داخلی را با خود حمل می کند. در این بخش خلاصه ای از متداول ترین تگ ها و فیلترها را مورد بررسی قرار خواهیم داد.
[/p]

[h4]id="96"[h4/]
تگ if/else
[/h4]

[p]id="97"[p/]
تگ {% if %} یک متغیر را مورد ارزیابی قرار می دهد، و در صورتی که مقدار متغیر True (مانند وجود داشتن، خالی نبودن، و مقدار False نبودن) بود، سیستم template جنگو هر آنچه را که بین تگ {% if %} و {% endif %} باشد را نمایش خواهد داد، مانند:
[/p]

[code html]
{% if today_is_weekend %}
    <p>Welcome to the weekend!</p>
{% endif %}
[/code]

[p]id="98"[p/]
استفاده از یک تگ {% else %} اختیاری می باشد:
[/p]

[code html]
{% if today_is_weekend %}
    <p>Welcome to the weekend!</p>
{% else %}
    <p>Get back to work.</p>
{% endif %}
[/code]

[note]
مقدار True و False در پایتون
[note/]
[p]id="99"[p/]
در پایتون و template system جنگو آبجکت های زیر به منزله ی False تلقی می شوند:
[/p]

[ul][ul/]
[li]id="100"[li/]
یک لیست خالی ([])
[/li]

[li]id="101"[li/]
یک تاپل خالی (())
[/li]

[li]id="102"[li/]
یک دیکشنری خالی ({})
[/li]

[li]id="103"[li/]
یک رشته ی خالی ('')
[/li]

[li]id="104"[li/]
عدد صفر (0)
[/li]

[li]id="105"[li/]
آبجکت ویژه ی None
[/li]

[li]id="106"[li/]
آبجکت False
[/li]

[li]id="107"[li/]
آبجکت های ساخته شده که رفتار داده ی Boolean خود را تعریف می کنند.
[/li]
[/ul]
[p]id="108"[p/]
به غیر از موارد فوق همه چیز True ارزیابی می شود.
[/p]
[/note]

[p]id="109"[p/]
تگ {% if %} عبارات and، or و not را برای آزمودن چندین متغیر، یا منفی کردن متغیر داده شده قبول می کند. به عنوان مثال:
[/p]

[code html]
{% if athlete_list and coach_list %}
    Both athletes and coaches are available.
{% endif %}

{% if not athlete_list %}
    There are no athletes.
{% endif %}

{% if athlete_list or coach_list %}
    There are some athletes or some coaches.
{% endif %}

{% if not athlete_list or coach_list %}
    There are no athletes or there are some coaches.
{% endif %}

{% if athlete_list and not coach_list %}
    There are some athletes and absolutely no coaches.
{% endif %}
[/code]

[p]id="110"[p/]
تگ های {% if %} اجازه ی نمی دهند عبارات and و or در یک تگ همسان استفاده شوند، دلیل آن است که ترتیب محاسبه ی آن ها مبهم خواهد بود. برای عنوان مثال کد زیر نا معتبر است:
[/p]

[code html]
{% if athlete_list and coach_list or cheerleader_list %}
[/code]

[p]id="111"[p/]
استفاده از پرانتز برای کنترل کردن ترتیب عملکردها در سیستم template پشتیبانی نمی شود. در صورتیکه نیاز به استفاده از پرانتز بود، می توان اعمال منطقی را بیرون از template انجام داده و نتیجه را به عنوان متغیر template ارسال کرد، و یا آنکه از تگهای {% if %} به صورت تودرتو استفاده کرد. مانند:
[/p]

[code html]
{% if athlete_list %}
    {% if coach_list or cheerleader_list %}
        We have athletes, and either coaches or cheerleaders!
    {% endif %}
{% endif %}
[/code]

[p]id="112"[p/]
استفاده از چند عملگر یکسان در یک تگ مجاز می باشد، ولی نمی توان عملگرهای متفاوت را بدین شکل استفاده کرد، برای مثال کد زیر معتبر می باشد:
[/p]

[code html]
{% if athlete_list or coach_list or parent_list or teacher_list %}
[/code]

[p]id="113"[p/]
تگی با نام {% elif %} وجود ندارد. می توان از تگ های {% if %} تودرتو برای این کار استفاده کرد:
[/p]

[code html]
{% if athlete_list %}
    <p>Here are the athletes: {{ athlete_list }}.</p>
{% else %}
    <p>No athletes are available.</p>
    {% if coach_list %}
        <p>Here are the coaches: {{ coach_list }}.</p>
    {% endif %}
{% endif %}
[/code]

[p]id="114"[p/]
اطمینان حاصل کنید که هر تگ {% if %} با یک تگ {% endif %} بسته شده است. در غیر اینصورت خطای TemplateSyntaxError ایجاد خواهد شد.
[/p]

[h4]id="115"[h4/]
تگ for
[/h4]

[p]id="116"[p/]
تگ {% for %} اجازه می دهد تا به ترتیب در سراسر ایتم های یک لیست یا ... چرخ بزنید. همانند عبارت for در پایتون؛ for X in Y، Y لیست مورد نظر می باشد و X در هر نوبت از حلقه یکی از ایتم های Y می باشد. سیستم template در هر بار، هر چیزی که بین {% for %} و {% endfor %} باشد را اجرا می کند.
[/p]

[p]id="117"[p/]
برای مثال، می توانید از کد زیر یک لیست از ورزشکاران را که به صورت متغیر athlete_list داده شده است را نمایش دهید:
[/p]

[code html]
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>
[/code]

[p]id="118"[p/]
اضافه کردن کلمه ی reversed موجب می شود که حلقه به صورت بر عکس جریان پیدا کند:
[/p]

[code html]
{% for athlete in athlete_list reversed %}
...
{% endfor %}
[/code]

[p]id="119"[p/]
می توان از تگ های {% for %} به صورت تودرتو نیز استفاده کرد:
[/p]

[code html]
{% for athlete in athlete_list %}
    <h1>{{ athlete.name }}</h1>
    <ul>
    {% for sport in athlete.sports_played %}
        <li>{{ sport }}</li>
    {% endfor %}
    </ul>
{% endfor %}
[/code]

[p]id="120"[p/]
می توان از الگوی کد زیر برای بررسی کردن اندازه ی لیست استفاده کرد، همچنین در صورت خالی بودن لیست، می توان یک پیام را نمایش داد:
[/p]

[code html]
{% if athlete_list %}
    {% for athlete in athlete_list %}
        <p>{{ athlete.name }}</p>
    {% endfor %}
{% else %}
    <p>There are no athletes. Only computer programmers.</p>
{% endif %}
[/code]

[p]id="121"[p/]
به دلیل آنکه الگوی فوق بسیار رایج می باشد، تگ for از یک تگ {% empty %} پشتیبانی می کند که به شما اجازه می دهد در صورت خالی بود لیست آنچرا که می خواهید تعریف کنید. مثال زیر معادل کد قبلی می باشد:
[/p]

[code html]
{% for athlete in athlete_list %}
    <p>{{ athlete.name }}</p>
{% empty %}
    <p>There are no athletes. Only computer programmers.</p>
{% endfor %}
[/code]

[p]id="122"[p/]
در سیستم template از عبارت break پشتیبانی نمی شود، بدین معنی که عبارتی برای شکستن روال عادی حلقه وجود ندارد. برای انجام چنین کاری می توان متغیر لیست را طوری تغییر داد که تنها حاوی مقادیری باشد که می خواهیم حلقه در آن بچرخد. به طور مشابه از عبارت continue نیز پشتیبانی نمی شود (از عبارت continue در پایتون برای انتقال حرکت حلقه به طور ناگهانی به ابتدای حلقه استفاده می شود.) (در همین فصل، در بخش فلسفه ی محدودیت ها دلیل محدودیت های فوق را درخواهید یافت.)
[/p]

[p]id="123"[p/]
داخل هر حلقه ی {% for %}، می توانید به یک متغیر template با نام forloop دسترسی پیدا کنید. این متغیر  دارای attribute هایی می باشد که دارای اطلاعاتی در مورد حرکت حلقه می باشند.
[/p]

[ul][ul/]
[li]id="124"[li/]
forloop.counter همواره عددی را نمایش می دهد که حاکی از تعداد حرکت حلقه می باشد، همچنین مقدار آن در بار اول حرکت حلقه عدد یک (1) می باشد:
[/li]

[code html]
{% for item in todo_list %}
    <p>{{ forloop.counter }}: {{ item }}</p>
{% endfor %}
[/code]

[li]id="125"[li/]
forloop.counter0 شبیه به forloop.counter می باشد، تنها فرق آن در این است که مقدار آن در اولین بار حرکت حلقه عدد صفر (0) می باشد.
[/li]

[li]id="126"[li/]
forloop.revcounter همواره عددی را نمایش می دهد که حاکی از تعداد ایتم های باقی مانده ی حلقه می باشد. در اولین حرکت حلقه مقدار آن مجموع ایتم های موجود در لیست می باشد. در آخرین حرکت حلقه مقدار آن برابر با عدد یک (1) خواهد بود.
[/li]

[li]id="127"[li/]
forloop.revcounter0 شبیه به forloop.revcounter می باشد، فرق آن در این است که در اولین حرکت حلقه مقدار آن به اندازه ی مجموع ایتم های لیست منهای یک می باشد و در آخرین حرکت حلقه مقدار آن برابر با عدد صفر (0) می باشد.
[/li]

[li]id="128"[li/]
forloop.first یک مقدار Boolean می باشد. در صورتی که حلقه در حرکت اول خود باشد مقدار True بر می گرداند که برای موارد خاص مناسب می باشد:
[/li]

[code html]
{% for object in objects %}
    {% if forloop.first %}<li class="first">{% else %}<li>{% endif %}
    {{ object }}
    </li>
{% endfor %}
[/code]

[li]id="129"[li/]
forloop.last یک مقدار Boolean می باشد. در صورتی که حلقه  در حرکت آخر خود باشد مقدار True بر می گرداند، بیشترین استفاده از این attribute برای گذاشتن علامت (|) مابین لیستی از لینک ها می باشد:
[/li]

[code html]
{% for link in links %}
{{ link }}
{% if not forloop.last %} | {% endif %}
{% endfor %}
[/code]

[p]id="130"[p/]
خروجی کد فوق چیزی شبیه به این خواهد بود:
[/p]

[pre][pre/]
Link1 | Link2 | Link3 | Link4
[/pre]

[p]id="131"[p/]
کاربرد رایج دیگر آن در قرار دادن ویرگول بین لغات می باشد:
[/p]

[code html]
Favorite places:
{% for p in places %}{{ p }}{% if not forloop.last %}, {% endif %}{% endfor %}
[/code]

[li]id="132"[li/]
forloop.parentloop در حلقه های تودرتو استفاده می شود، بدین صورت که از طریق آن می توان درون حلقه ی داخلی به attribute های حلقه ی خارجی دسترسی پیدا کرد:
[/li]

[code html]
{% for country in countries %}
    <table>
    {% for city in country.city_list %}
        <tr>
        <td>Country #{{ forloop.parentloop.counter }}</td>
        <td>City #{{ forloop.counter }}</td>
        <td>{{ city }}</td>
        </tr>
    {% endfor %}
    </table>
{% endfor %}
[/code]
[/ul]

[p]id="133"[p/]
متغیر  forloop تنها در داخل حلقه ها در دسترس می باشد. بعد از آنکه template به تگ {% endfor %} می رسد، forloop از بین می رود.
[/p]

[note]context و متغیر forloop[note/]
[p]id="134"[p/]
هنگامی درون تگ {% for %} متغیری همنام با forloop داشته باشید، برای جلوگیری از overwrite شدن متغیر forloop جنگو فرض می کند که متغیر forloop شما forloop.parentloop می باشد. نیازی به نگرانی درباره ی این موضوع نمی باشد ولی توصیه می شود متغیری با نام forloop درون template استفاده نشود.
[/p]
[/note]

[h4]id="135"[h4/]
تگ ifequal/ifnotequal
[/h4]

[p]id="136"[p/]
سیستم template جنگو به طور عمد یک زبان برنامه نویسی کامل نمی باشد، در نتیجه اجازه ی اجرای عبارت های دلخواه پایتون را نمی دهد. (برای اطلاعات بیشتر نسبت به این محدودیت به بخش فلسفه ی محدودیت ها در همین بخش مراجعه کنید.) با این وجود، سیستم template جنگو برای مقایسه ی دو مقدار و نمایش چیزی در صورت مساوی بودن آن ها امکانات کاملی را پشتیبانی می کند (برای این منظور تگ {% ifequal %} در جنگو پیش بینی شده است.)
[/p]

[p]id="137"[p/]
تگ {% ifequal %} دو مقدار را با هم مقایسه می کند و در صورت مساوی بودن، هر آنچه که مابین {% ifequal %} و {% endifequal %} می باشد را نمایش می دهد.
[/p]

[p]id="138"[p/]
مثال زیر دو متغیر user و currentuser را مقایسه می کند:
[/p]

[code html]
{% ifequal user currentuser %}
    <h1>Welcome!</h1>
{% endifequal %}
[/code]

[p]id="139"[p/]
همچنین می توان برای مقایسه ی دو مقدار از رشته ی خام درون تک کوتیشن و یا دابل کوتیشن استفاده کرد:
[/p]

[code html]
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% endifequal %}

{% ifequal section "community" %}
    <h1>Community</h1>
{% endifequal %}
[/code]

[p]id="140"[p/]
درست مثل {% if %}، تگ {% ifequal %} نیز به طور اختیاری از تگ {% else %} پشتیبانی می کند:
[/p]

[code html]
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% else %}
    <h1>No News Here</h1>
{% endifequal %}
[/code]

[p]id="141"[p/]
تنها متغیرهای template مانند؛ رشته ها، اعداد صحیح، و اعداد اعشاری می توانند به عنوان آرگومان {% ifequal %} قرار بگیرند. مثال های زیر معتبر می باشند:
[/p]

[code html]
{% ifequal variable 1 %}
{% ifequal variable 1.23 %}
{% ifequal variable 'foo' %}
{% ifequal variable "foo" %}
[/code]

[p]id="142"[p/]
نوع داده های دیگر از قبیل دیکشنری ها، لیست ها، و Boolean، برای {% ifequal %} مجاز نمی باشند. مثال های زیر نامعتبر می باشند:
[/p]

[code html]
{% ifequal variable True %}
{% ifequal variable [1, 2, 3] %}
{% ifequal variable {'key': 'value'} %}
[/code]

[h4]id="143"[h4/]
کامنت ها
[/h4]

[p]id="144"[p/]
تنها در HTML و پایتون، زبان template جنگو اجازه می دهد از  کامنت ها استفاده شود. برای طراحی یک کامنت از {# #} استفاده می شود:
[/p]

[code html]
{# This is a comment #}
[/code]

[p]id="145"[p/]
هنگامی که template اجرا می شود، کامنت ها هیچ خروجی ای نخواهند داشت.
[/p]

[p]id="146"[p/]
از تگ فوق نمی توان برای کامنت های چند خطی استفاده کرد. مثال زیر به عنوان کامنت در نظر گرفته نمی شود و مانند دیگر عبارت template به حساب می اید:
[/p]

[code html]
This is a {# this is not
a comment #}
test.
[/code]

[p]id="147"[p/]
در صورتیکه می خواهید از کامنت های چند خطی استفاده کنید؛ بایستی از تگ {% template comment %} مانند زیر استفاده کرد:
[/p]

[p]id="148"[p/]
{% comment %}This is amulti-line comment.{% endcomment %}
[/p]

[h4]id="149"[h4/]
فیلتر ها
[/h4]

[p]id="150"[p/]
همانطور پیش تر در این فصل توضیح داده شد، فیلترها روش های ساده ای برای تغییر مقدار متغیرها قبل از نمایش آن ها می باشند. فیلتر ها مانند زیر از علامت پایپ (|) استفاده می کنند:
[/p]

[code html]
{{ name|lower }}
[/code]

[p]id="151"[p/]
کد فوق مقدار متغیر {{ name }} را بعد از عبور از فیلتر lower به حروف کوچک انگلیسی تبدیل می کند.
[/p]

[p]id="152"[p/]
فیلترها می توانند به صورت زنجیروار نیز استفاده شوند؛ بدین صورت که آن ها می توانند پشت سر هم قرار بگیرند. در این حالت خروجی فیلتر قبلی وارد فیلتر بعدی شود. در مثال زیر اولین المان (element) لیست دریافت شده و به حروف بزرگ انگلیسی تبدیل می شود:
[/p]

[code html]
{{ my_list|first|upper }}
[/code]

[p]id="153"[p/]
بعضی فیلترها آرگومان نیز دریافت می کنند. آرگومان فیلتر بعد از علامت (:) و همواره داخل دابل کوتیشن مانند مثال زیر قرار می گیرد:
[/p]

[code html]
{{ bio|truncatewords:"30" }}
[/code]

[p]id="154"[p/]
مثال فوق 30 لغت اول متغیر bio را نمایش می دهد.
[/p]

[p]id="155"[p/]
در زیر تعداد از مهمترین فیلتر ها توضیح داده شده اند:
[/p]

[ul][ul/]
[li]id="156"[li/]
addslashes: فیلتر مذکور یک علامت (\) قبل از علامت های (\)، تک کتیشن، و دابل کوتیشن قرار می دهد. این فیلتر برای متن های تولید شده درون رشته های جاوا اسکریپت مفید می باشند.
[/li]

[li]id="157"[li/]
date: تاریخ و یا زمان را بر طبق قالبی که به آن به عنوان پارامتر داده می شود، مانند مثال زیر قالب بندی می کند:
[/li]

[code html]
{{ pub_date|date:"F j, Y" }}
[/code]

[li]id="158"[li/]
length: طول یک مقدار را بر می گرداند. برای یک لیست، تعداد المان های آن و برای یک رشته تعداد حروف آن را بر می گرداند. (توسعه دهندگان پایتون توجه داشته باشند که این فیلتر برای هر آبجکت پایتونی که تحوه تعیین طول آن مشخص شده باشد کار می کند؛ مانند هر آبجکتی که دارای متد [چپ]__len__()[/چپ] باشد.)
[/li]
[/ul]

[h3]id="159"«هس/»
فلسفه ی محدودیت ها
[/h3]

[p]id="160"[p/]
اکنون که تا حد زیادی با زبان template جنگو آشنا شده اید، وقت آن رسیده است که به برخی از محدودیت های عمدی موجود در این زبان، به همراه فلسفه ی این که چرا این زبان به این شکل کار می کند اشاره کنیم.
[/p]

[p]id="161"[p/]
قواعد زبان template جنگو ،بیشتر از هر جزء دیگری از برنامه های وب، بسیار خصوصی بوده و انتخاب های برنامه نویس بسیار گسترده می باشد. حقیقتی است که پایتون دارای پشتیبانی از ده ها زبان template سورس باز می باشد. که احتمالا هر کدام به این دلیل ساخته شده اند که توسعه دهنده معتقد بر این بوده است که زبان های template موجود، کافی نمی باشند. (در حقیقت،  این فرمان عبور، برای یک توسعه دهنده پایتون، برای نوشتن زبان template خودش می باشد، اگر تاکنون همچین کاری نکرده اید، می توانید آن را امتحان، زیرا یک تمرین جالب می باشد.)
[/p]

[p]id="162"[p/]
با در نظر گرفتن این موضوع، جالب است این را بدانید که جنگو نیازی به استفاده از زبان template آن ندارد؛ یعنی می توان از هر زبان template دیگر نیز استفاده کرد. زیرا جنگو برای این در نظر گرفته شده است که یک فریم ورک وب full-stack برای تهیه ی تمام قسمت های ضروری برای توسعه دهندگان باشد تا یک تولید کننده باشند، خیلی وقت ها استفاده از سیستم template جنگو مناسب تر از کتابخانه های templte دیگر پایتون می باشد، ولی این یک نیازمندی موکد نمی باشد. همانطور که در بخش اینده ی  این فصل "استفاده از template ها در view" مشاهده خواهید کرد، استفاده از زبان های template دیگر بسیار آسان می باشد.
[/p]

[p]id="163"[p/]
واضح است که ترجیح می دهیم از خود زبان template جنگو استفاده کنیم. template system دارای اصولی نسبت به نحوه ی توسعه ی وب انجام شده در World Online و تجربیات متعدد سازندگان جنگو می باشد. در زیر به تعدادی از این فلسفه ها اشاره خواهیم کرد:
[/p]

[ul][ul/]
[li]id="164"[li/]
منطق برنامه (Business logic) باید از ارائه منطق (Presentation logic) جدا باشد. توسعه دهندگان جنگو، سیستم template جنگو را تنها به چشم ابزاری برای کنترل نمایش و نمایش منطق نگاه می کنند و نه بیشتر. سیستم template جنگو نباید از حالت تابع گرایی پشیتبانی کند که از این هدف اصلی خارج شود.
[/li]

[p]id="165"[p/]
به همین دلیل، فراخوانی کد پایتون به طور مستقیم درون template های جنگو امکان پذیر نیست. تمام برنامه نویسی، اساسا محدود به محدوده ی تگ های template ها و آن چه که می توان در این محدوده انجام داد می باشد. می توان از تگ های سفارشی template برای انجام وظایف دلخواه استفاده کرد، ولی در صورتی که خارج از تگ های template جنگو باشد به طور عمدی اجازه داده نخواهد شد کد پایتون دلخواه اجرا شود.
[/p]

[li]id="166"[li/]
کد template باید از HTML/XML جدا باشد. اگرچه سیستم template برای تولید HTML استفاده می شود، ولی سیستم template تنها باری قالب های غیر HTML ای، مانند متن ساده در نظر گرفته شده است. برخی از زبان های دیگر template ای که بر اساس XML می باشند، در آن ها تمام منطق template داخل تگ ها یا attribute ها XML قرار می گیرند، در صورتیکه جنگو به صورت عمدی از این محدودیت اجتناب کرده است. استفاده از XML می تواند موجب بوجود آمدن اشتباهات غیر قابل اجتناب شود که پیام های خطای آن نیز کمی غیر قابل فهم می باشند، همچنین استفاده از موتور XML برای parse کردن template ها باعث ایجاد یک سری وظایف اضافه ی غیر قابل قبول در پردازش template می شود.
[/li]

[li]id="167"[li/]
راحتی طراحان برای کار با کد HTML در نظر گرفته شده است. سیستم template طوری طراحی نشده است که به زیبایی قابل نمایش درون editor هایی مانند Dreamweaver نمایش داده شود. جنگو از نویسندگان template انتظار دارد به طور مستقیم و راحت HTML را ویرایش کنند.
[/li]

[li]id="168"[li/]
فرض بر این است که طراحات HTML برنامه نویسان پایتون نیستند. نسبت به این که اغلب template های صفحات وب به وسیله ی طراحان نوشته شده است نه برنامه نویسان، بنابراین در template system دانش پایتون فرض نشده است.
[/li]

[li]id="169"[li/]
هدف اختراع یک زبان برنامه نویسی نیست. هدف تنها ارائه ی یک سبک برنامه نویسی مانند استفاده از حلقه و غیره می باشد، که برای ایجاد یک نمایش از تصمیمات ضروری می باشد.
[/li]
[/ul]

[h3]id="170"«هس/»
استفاده از template ها در view
[/h3]

[p]id="171"[p/]
اصول اولیه ی استفاده از template system را آموختیم؛ اجازه دهید از این دانش برای ساخت view استفاده کنیم.  تابع current_datetime را در ماژول mysite.views که در فصل گذشته ساخته شد را دوباره فراخوانی کنید:
[/p]

[code]
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
[/code]

[p]id="172"[p/]
اجازه دهید view فوق را با استفاده از سیستم template جنگو تغییر دهیم. در ابتدا ممکن است فکر کنید، باید کاری شبیه به کد فوق را انجام دهید:
[/p]

[code]
from django.template import Template, Context
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    t = Template("<html><body>It is now {{ current_date }}.</body></html>")
    html = t.render(Context({'current_date': now}))
    return HttpResponse(html)
[/code]

[p]id="173"[p/]
مطمئنا از template system استفاده خواهیم کرد، ولی روش فوق مشکلات که در ابتدای فصل به آن اشاره کردیم را حل نمی کند. به عنوان مثال، template همچنان درون کد پایتون می باشد. می توان مشکل فوق را با جدا کردن template درون فایلی دیگر حل کرد، به طوری که فایل مذکور درون view بار گذاری شود.
[/p]

[p]id="174"[p/]
ممکن است ابتدا اینطور به نظر برسد که template را درون جایی روی سیستم ذخیره کردن و با استفاده از توابع داخلی پایتون محتویات فایل مورد نظر را بخوانید. در مثال زیر فرض شده است که template درون فایل /home/djangouser/templates/mytemplate.html ذخیره شده است:
[/p]

[code]
from django.template import Template, Context
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    # Simple way of using templates from the filesystem.
    # This is BAD because it doesn't account for missing files!
    fp = open('/home/djangouser/templates/mytemplate.html')
    t = Template(fp.read())
    fp.close()
    html = t.render(Context({'current_date': now}))
    return HttpResponse(html)
[/code]

[p]id="175"[p/]
روش فوق نیز با توجه به معایبی که در ادامه بیان می کنیم، روش مناسبی نمی باشد:
[/p]

[ul][ul/]
[li]id="176"[li/]
روش فوق در زمان نبود فایل به هیچ وجه کار نخواهد کرد. فراخوانی [چپ]open()[/چپ]، در صورتیکه فایل mytemplate.html وجود نداشته باشد و یا اینکه قابل خواندن نباشد باعث ایجاد خطای IOError خواهد شد.
[/li]

[li]id="177"[li/]
مکان template در این روش داخل کد پایتون قرار خواهد گرفت. در صورت استفاده از این تکنیک برای هر تابع view، باید درون هر فایل به صورت تکراری آدرس فایل را قرار بدهیم.
[/li]

[li]id="178"[li/]
روش فوق حاوی تعداد زیادی کدهای تکراری خسته کننده می باشد. در هر فایل شما باید [چپ]fp.open()[/چپ] ،[چپ]fp.read()[/چپ] و [چپ]fp.close()[/چپ] را قرار دهید و بدیهی است که در صورت فراموش کردن این کدها برنامه شما با مشکل روبرو می شود.
[/li]
[/ul]

[p]id="179"[p/]
برای حل کردن موارد فوق، از بار گذاری template و دایرکتوری های آن استفاده می شود.
[/p]

[h4]id="180"[h4/]
بار گذاری Template
[/h4]

[p]id="181"[p/]
جنگو با هدف حذف کردن کدهای اضافه در برنامه هنگام فراخوانی و همچنین درون template، برای بارگذاری template ها یک API بسیار مناسب و قدرتمند تهیه کرده است.
[/p]

[p]id="182"[p/]
به منظور استفاده از API بار گذاری template، ابتدا می بایست به فریم بگویید که template ها را در کجا ذخیره خواهید کرد. برای انجام چنین کاری نیازمند فایل settings می باشید. (در فصل گذشته هنگام معرفی تنظیم ROOT_URLCONF، در مورد فایل settings.py صحبت شد.)
[/p]

[p]id="183"[p/]
اگر از ابتدا کتاب را دنبال کرده اید، فایل settings.py را باز کرده و تنظیم TEMPLATE_DIRS را پیدا کنید. تنظیم فوق، یک تاپل خالی که احتمالا حاوی برخی کامنت های پیشفرض که به صورت خودکار تولید شده است، می باشد:
[/p]

[code]
TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)
[/code]

[p]id="184"[p/]
تنظیم فوق به مکانیسم بار گذاری template جنگو می گوید که باید در کجا به دنبال template ها بگردد. مسیر و دایرکتوری را که می خواهید template های خود را ذخیره کنید مانند مثال زیر درون TEMPLATE_DIRS اضافه کنید:
[/p]

[code]
TEMPLATE_DIRS = (
    '/home/django/mysite/templates',
)
[/code]

[p]id="185"[p/]
توجه به چند نکته ضروری است:
[/p]

[ul][ul/]
[li]id="186"[li/]
می توانید هر مسیری را که می خواهید تعیین کنید، البته تا زمانیکه مسیر و template ها برای کاربر قابل خواندن باشد. در صورتیکه جای مناسبی را برای template های خود به یاد نمی آورید، پیشنهاد می کنیم یک دایرکتوری داخل پروژه ی خود بسازید (داخل دایرکتوری mysite که در فصل دوم ساخته شد).
[/li]

[li]id="187"[li/]
در صورتیکه حاوی تنها یک مسیر می باشد، فراموش نکنید که در پایان رشته ی آدرس یک علامت کاما (,) قرار دهید!
[/li]

[p]id="188"[p/]
غلط:
[/p]

[code]
# Missing comma!
TEMPLATE_DIRS = (
    '/home/django/mysite/templates'
)
[/code]

[p]id="189"[p/]
صحیح:
[/p]

[code]
# Comma correctly in place.
TEMPLATE_DIRS = (
    '/home/django/mysite/templates',
)
[/code]

[p]id="190"[p/]
دلیل حرکت فوق این است که پایتون از طریق علامت کاما بتواند تشخیص دهد که عبارت فوق یک تاپل می باشد، نه یک عبارت ساده ی داخل پرانتز.
[/p]

[li]id="191"[li/]
اگر شما با سیستم عامل ویندوز کار می کنید، درون آدرس مورد نظر می بایست نام حرف دیسک درایو را اضافه کرده و همچنین مانند مثال زیر بجای علامت (\) از علامت (/) استفاده کنید:
[/li]

[code html]
TEMPLATE_DIRS = (
    'C:/www/django/templates',
)
[/code]

[li]id="192"[li/]
ساده ترین راه این است که از آدرس های کامل (بدین معنی که مسیر دایرکتوری ها از ریشه ی سیستم آدرس دهی شود) استفاده کنید. همانطور که می دانید فایل settings تنها کد پایتون می باشد و با استفاده از این خصوصیت می توان کمی منعطف تر از قبل کار کرد، بدین صورت که می توان آدرس دهی درون تنظیم TEMPLATE_DIRS را به صورت پویا مانند زیر طراحی کرد:
[/li]

[code]
import os.path

TEMPLATE_DIRS = (
    os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),
)
[/code]

[p]id="193"[p/]
مثال فوق از متغیر مجیک (magic) پایتون یعنی __file__ استفاده کرده است، بدین صورت که این متغیر به صورت خودکار حاوی نام فایل ای می باشد که در آن است. همچنین با استفاده از os.path.dirname نام دایرکتوری ای که حاوی فایل settings.py می باشد بدست می اید، سپس رشته ی template که در دومین پارامتر داده است به انتهای آن اضافه می شود و در پایان جای علامت های (\\) با علامت (/) جایگزین می باشد (اگر در سیستم عامل ویندوز باشید.)
[/p]

[p]id="194"[p/]
هنگامی که درون فایل settings.py از کد پویای پایتون استفاده کنید، باید اشاره کنیم که درون فایل settings.py از هرگونه خطا و اشتباه کد پایتون جلوگیری کنید. در صورتیکه درون این فایل یک خطای نوشتاری و یا خطای runtime وجود داشته باشد، سایت ایجاد شده توسط جنگو معیوب خواهد شد.
[/p]
[/ul]

[p]id="195"[p/]
بعد از تنظیم TEMPLATE_DIRS، گام بعدی تغییر کد view می باشد که باید از بار گذاری template به جای استفاده مستقیم template، استفاده کرد. باز می گردیم به تابع current_datetime، و آن را مانند زیر تغییر می دهیم:
[/p]

[code]
from django.template.loader import get_template
from django.template import Context
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    t = get_template('current_datetime.html')
    html = t.render(Context({'current_date': now}))
    return HttpResponse(html)
[/code]

[p]id="196"[p/]
در مثال فوق، از تابع [چپ]django.template.loader.get_template()[/چپ] بجای بارگذاری template از سیستم به صورت دستی استفاده شده است. تابع [چپ]get_template()[/چپ] نام template را به عنوان آرگومان دریافت کرده، و محلی را در سیستم template در آن وجود دارد را پیدا کرده، آن را باز کرده و و یک آبجکت template کامپایل شده را بر می گرداند.
[/p]

[p]id="197"[p/]
template مورد نظر در مثال فوق current_datetime.html می باشد، ولی هیچ چیز خاصی درباره ی پسوند .html وجود ندارد. شما می توانید هر پسوندی که می خواهید برای آن قرار دهید، و یا حتی می توانید پسوند فایل را کلا حذف کنید.
[/p]

[p]id="198"[p/]
برای تعیین مکان template در روی سیستم، تابع [چپ]get_template()[/چپ] مسیر فایل را که در TEMPLATE_DIRS وجود دارد را با نام template که به آن ارسال می کنید ترکیب می کند. به عنوان مثال اگر TEMPLATE_DIRS حاوی آدرس /home/django/mysite/templates باشد، تابع [چپ]get_template()[/چپ] مثال فوق فایل زیر را جستجو خواهد کرد.
[/p]

[pre][pre/]
/home/django/mysite/templates/current_datetime.html
[/pre]

[p]id="199"[p/]
در صورتیکه تابع [چپ]get_template()[/چپ] موفق به یافتن template با نام داده شده نشود، خطای TemplateDoesNotExist ایجاد خواهد شد. برای دیدن خطای فوق سرور جنگو را با دستور python manage.py runserver درون دایرکتوری پروژه جنگو اجرا کنید. سپس مرورگر خود را باز کرده و به آدرس مورد نظر برای مثال http://127.0.0.1:8000/time/ بروید. با فرض اینکه تنظیم DEBUG به صورت True می باشد و هنوز template مورد نظر یعنی current_datetime.html ساخته نشده است، شما باید یک صفحه خطای جنگو را با نام TemplateDoesNotExist مشاهده کنید.
[/p]

[image]شکل 1-4[image/]
[img]src='/statics/images/4-1.jpg' width='100%'[image/]
[/image]

[p]id="200"[p/]
صفحه ی خطای فوق همانند صفحه ای است که در فصل سوم توضیح داده شد، تنها با یک قسمت اطلاعات اضافه تر: بخش Template-loader postmortem. این بخش به شما می گوید که جنگو کدام template ها را بار گذاری کرده است، و همچنین دلیل رد کردن template ها را نیز در بر می گیرد (مانند File does not exist). این اطلاعات هنگامی که شما می خواهید خطاهای بارگذاری template را بر طرف کنید بسیار با ارزش می باشند.
[/p]

[p]id="201"[p/]
در پایان می بایست current_datetime.html را درون دایرکتوری template خود ساخته و کد زیر را درون آن قرار دهید:
[/p]

[code html]
<html><body>It is now {{ current_date }}.</body></html>
[/code]

[p]id="202"[p/]
صفحه را ذخیره کرده و صفحه ی مرورگر خود را به اصطلاح refresh کنید، شما می بایست صفحه تولید شده حاوی زمان و تاریخ فعلی خود را مشاهده کنید.
[/p]

[h3]id="203"«هس/»
تابع [چپ]render_to_response()[/چپ]
[/h3]

[p]id="204"[p/]
همانطور که قبلا اشاره کردیم، بارگذاری یک template شامل پر کردن یک Context و بر گرداندن نتیجه ی یک template توسط یک آبجکت HttpResponse، می باشد. همانطور که گفته شد در روش فوق با استفاده از [چپ]get_template()[/چپ] به جای template های مستقیم و یا آدرس درون کد، توانستیم کد خود را بهینه تر کنیم. ولی همچنان نیاز به یک حرکت زیبا برای بهینه تر کردن کد وجود دارد. جنگو یک میانبر (shortcut) ارائه می دهد که از طریق آن تنها می توان با یک خط کد template را بار گذاری کرده، آن را ارائه داده و یک HttpResponse را بر گردانید.
[/p]

[p]id="205"[p/]
این میانبر یک تابع است که [چپ]render_to_response()[/چپ] نام دارد، که در ماژول django.shortcuts قرار دارد. اغلب اوقات شما بجای بارگذاری template ها و ساختن Context و آبجکت ها HttpResponse به صورت دستی از [چپ]render_to_response()[/چپ] استفاده خواهید کرد، مگر آنکه کارفرای شما بر اساس مجموع خط های موجود در کدی که نوشته اید نسبت به کار شما تصمیم گیری کند.
[/p]

[p]id="206"[p/]
در زیر تابع بهینه شده ی current_datetime که با استفاده از [چپ]render_to_response()[/چپ] دوباره نویسی شده است را مشاهده می کنید:
[/p]

[code]
from django.shortcuts import render_to_response
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response('current_datetime.html', {'current_date': now})
[/code]

[p]id="207"[p/]
آن چه که تغییر پیدا کرده است:
[/p]

[ul][ul/]
[li]id="208"[li/]
در مثال فوق get_template، Template، Context و HttpResponse دیگر import نشده اند، و به جای آن ها تنها  django.shortcuts.render_to_response، import شده است.
[/li]

[li]id="209"[li/]
داخل تابع current_datetime، همچنان متغیر now محاسبه شده است، ولی بارگذاری template، ساختن Context، ارائه ی template و ساختن HttpResponse تماما تنها با فراخوانی [چپ]render_to_response()[/چپ] انجام شده است. زیرا [چپ]render_to_response()[/چپ] یک آبجکت HttpResponse بر می گرداند، و تنها کافی است آن مقدار را در view بر گردانده شود.
[/li]
[/ul]

[p]id="210"[p/]
اولین آرگومان تابع [چپ]render_to_response()[/چپ] نام template مورد استفاده می باشد. دومین آرگومان در صورت ارسال، باید یک دیکشنری باشد که جهت ساختن Context برای template استفاده می شود. در صورتیکه دومین آرگومان را ارسال نکنید، [چپ]render_to_response()[/چپ] از یک دیکشنری خالی استفاده می کند.
[/p]

[h3]id="211"«هس/»
تکنیک [چپ]locals()[/چپ]
[/h3]

[p]id="212"[p/]
آخرین تابع current_datetime نوشته شده ملاحظه کنید:
[/p]

[code]
def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response('current_datetime.html', {'current_date': now})
[/code]

[p]id="213"[p/]
درون یک برنامه شما چندین بار مانند مثال فوق، مقادیری را حساب کرده و درون متغیرهایی ذخیره می کنید (مانند متغیر now در کد قبلی)،  و متغیرها را به template مورد نظر ارسال می کنید. برنامه نویسان راحت طلب باید توجه داشته باشند که این کمی اضافه کاری است که باید متغیرها موقت ساخته و نام گذاری کنند و نام آن ها را برای template ارسال کنند. نه تنها این کار زائدی می باشد، بلکه تایپ اضافی درون برنامه نیز می باشد.
[/p]

[p]id="214"[p/]
پس اگر شما جزء آن دسته از برنامه نویسان راحت طلب می باشید که مایلند کد خود را کوتاه و مختصر نگه دارند، می توانید از یک تابع داخلی پایتون به نام [چپ]locals()[/چپ] استفاده کنید. این تابع یک دیکشنری بر می گرداند که حاوی نام تمام متغیرهای محلی و ارزش هایشان می باشد، متغیرهای محلی به متغیرهایی گفته می شود که داخلی محدوده ی فعلی تعریف شده باشند. در نتیجه، view قبلی را می تواند به صورت زیر بازنویسی کرد:
[/p]

[code]
def current_datetime(request):
    current_date = datetime.datetime.now()
    return render_to_response('current_datetime.html', locals())
[/code]

[p]id="215"[p/]
در مثال فوق، بجای تعیین کردن دیکشنری context به صورت دستی همانند قبل، مقدار [چپ]locals()[/چپ] ارسال شده است، که شامل تمام متغیرهای تعریف شده در آن نقطه از اجرای تابع می باشد. در نتیجه، متغیر now به current_date تغییر نام پیدا کرده است، زیرا درون template نیز نام current_date معرفی شده است. در مثال فوق، [چپ]locals()[/چپ] یک پیشرفت عظیم را ارائه نمی کند، ولی این تکنیک می تواند شما را از شر تایپ کردن زیاد خلاص می کند، البته اگر شما چندین متغیر template برای تعریف دارید و یا اینکه کمی تنبل هستید.
[/p]

[p]id="216"[p/]
چیزی که باید در مورد استفاده از [چپ]locals()[/چپ] مراقب آن باشید این است که این تابع حاوی  تمام متغیرهای محیطی و شاید خیلی بیشتر از آنچه شما واقعا نیاز دارید می باشد، در مثال قبلی، [چپ]locals()[/چپ] همچنین حاولی request نیز می باشد. البته استفاده از [چپ]locals()[/چپ] به برنامه و نوع استفاده شما بستگی دارد.
[/p]

[h4]id="217"[h4/]
دایرکتوری های زیر مجموعه در [چپ]get_template()[/چپ]
[/h4]

[p]id="218"[p/]
ذخیره ی تمام template ها درون یک دایرکتوری می تواند کمی سنگین باشد. ممکن است بخواهید template ها را درون دایرکتوری های زیر مجموعه ی دایرکتوری template قرار داهید.
[/p]

[p]id="219"[p/]
ذخیره ی template ها درون دایرکتوری های زیرمجموعه ی دایرکتوری template بسیار آسان می باشد. تنها کافیست درون [چپ]get_template()[/چپ]، نام دایرکتوری زیرمجموعه و بعد از آن یک علامت (/) و بعد نام template را قرار دهید:
[/p]

[code]
t = get_template('dateapp/current_datetime.html')
[/code]

[p]id="220"[p/]
همچنین می توانید از این امکان در تابع [چپ]render_to_response()[/چپ] نیز استفاده کنید بدین صورت که اعمال فوق را درون اولین پارامتر این تابع قرار می دهید:
[/p]

[code]
return render_to_response('dateapp/current_datetime.html', {'current_date': now})
[/code]

[p]id="221"[p/]
هیچ محدودیتی نسبت به تعداد دایرکتوری های زیر مجموعه ی استفاده شده وجود ندارد و می توانید در صورت نیاز از هر تعداد از آن ها استفاده کنید.
[/p]

[note]
نکته
[note/]
[p]id="222"[p/]
کاربران ویندوز، مطمئن شوید که از علامت (/) به جای (\) استفاده می کنید. تابع [چپ]get_template()[/چپ] طراحی آدرس دهی را بر اساس Unix-style فرض می کند.
[/p]
[/note]

[h4]id="223"[h4/]
تگ include
[/h4]

[p]id="224"[p/]
اکنون که مکانیزم بارگذاری template شرح داده شده است، می توان یک تگ داخلی template و مزایای آن را معرفی کرد: {% include %}. این تگ اجازه می دهد تا محتویات template های دیگر را درون template فعلی وارد کرد. آرگومان این تگ باید نام template ای باشد که می خواهید وارد template فعلی بکنید. همچنین این آرگومان می تواند یک متغیر و یا کد مستقیم HTML باشد که درون تک کتیشن یا دابل کتیشن قرار دارد. زمانی که یک کد همسان درون چندین template وجود دارد، می توان برای جلوگیری از تکرار کد نویسی از تگ include استفاده کرد.
[/p]

[p]id="225"[p/]
هر دو مثال زیر برای include معتبر می باشند:
[/p]

[code html]
{% include 'nav.html' %}
{% include "nav.html" %}
[/code]

[p]id="226"[p/]
مثال زیر محتویات template، includes/nav.html را وارد template خواهد کرد:
[/p]

[code html]
{% include 'includes/nav.html' %}
[/code]

[p]id="227"[p/]
مثال زیر محتویات template ای را که نامش درون متغیر template_name ذخیره شده است را وارد می کند:
[/p]

[code html]
{% include template_name %}
[/code]

[p]id="228"[p/]
همانند [چپ]get_template()[/چپ]، نام فایل template با اضافه شدن به مسیر دایرکتوری template که در تنظیم TEMPLATE_DIRS قرار دارد تعیین می شود.
[/p]

[p]id="229"[p/]
template های وارد شده با context مربوط به template که آن ها را وارد کرده است ارزیابی می شوند. به عنوان مثال دو template زیر را ملاحظه کنید.
[/p]

[code html]
# mypage.html

<html>
<body>
{% include "includes/nav.html" %}
<h1>{{ title }}</h1>
</body>
</html>

# includes/nav.html

<div id="nav">
    You are in: {{ current_section }}
</div>
[/code]

[p]id="230"[p/]
در صورتیکه که شما mypage.html را با یک context حاوی current_section ارائه (render) کنید، متغیر template وارد شده همانطور که انتظار خواهید داشت در دسترس خواهد بود.
[/p]

[p]id="231"[p/]
در صورتیکه یک تگ [چپ]{% include %}، template[/چپ] ای را وارد کند که وجود نداشته باشد، یکی از حالت های زیر پیش می اید:
[/p]

[ul][ul/]
[li]id="232"[li/]
اگر تنظیم DEBUG به صورت True در نظر گرفته شده باشد، صفحه ی خطای جنگو با خطای TemplateDoesNotExist نمایش داده خواهد شد.
[/li]

[li]id="233"[li/]
اگر تنظیم DEBUG به صورت False در نظر گرفته شده باشد، تگ مورد نظر بدون هیچ خطایی رد شده، و درون قسمت تگ include چیزی نمایش داده نخواهد شد.
[/li]
[/ul]

[h3]id="234"«هس/»
ارث بری در Template
[/h3]

[p]id="235"[p/]
مثال های template ای که تاکنون استفاده شده است از نظر محتوی خیلی مختصر و کم حجم بوده اند. ولی در دنیای واقعی، شما تز template system جنگو برای ساختن صفحات HTML با حجم و محتویات بسیار گسترده استفاده خواهید کرد. در این صورت با یک مشکل مشترک و عمومی توسعه ی وب رو به رو خواهید بود:  چگونه می توان از بوجود آمدن صفحات و کدها تکراری در ساخت صفحات وب که اجتناب ناپذیر است جلوگیری کرد؟
[/p]

[p]id="236"[p/]
روش عمومی برای حل این مشکل استفاده از incude های سمت سرور می باشد، دستورالعمل هایی که شما می توانید داخل صفحه ی خود صفحات دیگر را نیز وارد کنید. در واقع، جنگو از این روش با استفاده از تگ template {% include %} پشتیبانی می کند که توضیح آن پیش تر داده شده است. ولی روش بهتری برای حل این مشکل وجود دارد که یکی از استراتژی های مطلوب جنگو به شمار می اید که "ارث بری template" نام دارد.
[/p]

[p]id="237"[p/]
در واقع، ارث بری template، این اجازه را می دهد که یک اسکلت بندی پایه و اولیه از template بسازید که حاوی  تمام بخش های عمومی می باشد. این بخش ها به صورت block ها تعریف می شوند و template هایی که از آن template پدر، ارث بری می کنند می توانند آن بخش ها را دوباره نویسی و یا به اصطلاح overwrite کنند.
[/p]

[p]id="238"[p/]
به مثال زیر توجه کنید، که همان بر روی template قبلی یعنی current_datetime.html موضوع فوق را توضیح داده است:
[/p]

[code html]
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
    <title>The current time</title>
</head>
<body>
    <h1>My helpful timestamp site</h1>
    <p>It is now {{ current_date }}.</p>

    <hr>
    <p>Thanks for visiting my site.</p>
</body>
</html>
[/code]

[p]id="239"[p/]
تا اینجا مشکلی وجود نخواهد داشت، ولی چه اتفاقی می افتد اگر بخواهید یک template برای یک view دیگر  مانند تابع hours_ahead که در فصل سوم وجود داشت ایجاد کنید؟ در صورتیکه بخواهید یک template کامل دیگر برای view دوم بسازید، چیزی شبیه به مثال  زیر خواهد بود:
[/p]

[code html]
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
    <title>Future time</title>
</head>
<body>
    <h1>My helpful timestamp site</h1>
    <p>In {{ hour_offset }} hour(s), it will be {{ next_time }}.</p>

    <hr>
    <p>Thanks for visiting my site.</p>
</body>
</html>
[/code]

[p]id="240"[p/]
کاملا واضح هست که مقدار زیادی کد تکراری در دو مثال فوق وجود دارد. تصور کنید اگر بخواهید صفحات بیشتری داشته باشید مانند یک سایت بزرگ که حاوی style sheet ها و یا مقادیر زیادی کد Java Script می باشد چه خواهید کرد؟
[/p]

[p]id="241"[p/]
راهکار include سمت سرور برای این مشکل راه حل مناسبی نمی باشد، چرا که به عنوان مثال برای قسمت بالایی کد شما یک template با نام header.html خواهید داشت:
[/p]

[code html]
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
[/code]

[p]id="242"[p/]
و برای قسمت پایین کد یک template با نام footer.html مانند مثال زیر:
[/p]

[code html]
    <hr>
    <p>Thanks for visiting my site.</p>
</body>
</html>
[/code]

[p]id="243"[p/]
با یک استراتژی مانند ارث بری هر دو قسمت بسیار آسان پیاده سازی خواهند شد. در مثال فوق هر دو صفحه تیتر صفحه را نشان می دهند (<h1>My helpful timestamp site</h1>) و نمی توان آن را درون header.html قرار داد، چرا که <title> در هر صفحه متفاوت از صفحه ی دیگر خواهد بود. و اگر <titile>  درون header.html قرار داده می شد، دیگر امکان تغییر آن برای هر صفحه به طور جدا گانه امکان پذیر نبود و تمام صفحات می بایست یک <title> را نمایش بدهند.
[/p]

[p]id="244"[p/]
ارث بری template جنگو این مشکلات را حل کرده است. نسخه ی insite-out از include های سمت سرور را بیاد می آورید. به جای تعریف تکه کد های مشترک، تکه کد هایی که تعریف می شوند متفاوت از یکدیگر هستند.
[/p]

[p]id="245"[p/]
اولین گام برای تعریف یک template پدر، یک اسکلت بندی از صفحه ی شما که template های فرزند بعدا آن را پر خواهند کرد. در مثال زیر یک template پدر تعریف شده است:
[/p]

[code html]
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
    <title>{% block title %}{% endblock %}</title>
</head>
<body>
    <h1>My helpful timestamp site</h1>
    {% block content %}{% endblock %}
    {% block footer %}
    <hr>
    <p>Thanks for visiting my site.</p>
    {% endblock %}
</body>
</html>
[/code]

[p]id="246"[p/]
مثال فوق که base.html نام دارد، یک اسکلت بندی ساده ی HTML می باشد که برای تمام صفحات استفاده خواهد شد. صفحات درون سایت که از صفحه ی فوق ارث بری کرده اند و به عبارتی صفحات فرزند نامیده می شوند می توانند خصوصیات مشخص شده در کلاس پدر را بازنویسی و یا تغییر دهند، می توانند خصوصیاتی را اضافه کنند و حتی می توانند خصوصیتی را نیز حذف کنند و در خودشان از استفاده نکنند. (در صورتیکه با مثال های کتاب پیش میروید فایل فوق را با نام base.html درون دایرکتوری template ذخیره کنید.)
[/p]

[p]id="247"[p/]
در اینجا از یک تگ template ای که آن را مشاهده کرده اید استفاده می کنید: تگ {% block %}. تمام تگ های {% block %} به موتور template این را می گویند که template فرزند ممکن است این قسمت از template را باز نویسی کند.
[/p]

[p]id="248"[p/]
اکنون یک template پدر موجود می باشد، می توان از آن در فایل current_datetime.html به شکل زیر استفاده کرد:
[/p]

[code html]
{% extends "base.html" %}

{% block title %}The current time{% endblock %}

{% block content %}
<p>It is now {{ current_date }}.</p>
{% endblock %}
[/code]

[p]id="249"[p/]
همچنین فایل hours_ahead را نیز که در فصل سوم در مورد آن صحبت شده است را نیز در مثال زیر مشاهده خواهید کرد: (در صورتیکه همگام با مثال های کتاب پیش میروید hours_ahead را از حالت قبلی که به صورت کد مستقیم درون view نوشته شده است خارج کرده و مانند زیر به صورت یکی از template ها درون دایرکتوری template دخیره کنید.)
[/p]

[code html]
{% extends "base.html" %}

{% block title %}Future time{% endblock %}

{% block content %}
<p>In {{ hour_offset }} hour(s), it will be {{ next_time }}.</p>
{% endblock %}
[/code]

[p]id="250"[p/]
آیا روش فوق روش زیبایی نیست؟ هر template حاوی کدهای منحصر به خود می باشد. هیچ کد زائدی وجود ندارد. در صورتیکه نیاز به تغییر طراحی در یک سایت عظیم دارید، تنها کافیست که درون template پدر تغییر ایجاد کنید، در اینصورت تمام template هایی که از کلاس پدر ارث بری کرده اند نیز به سرعت تغییر خواهند خواهند کرد.
[/p]

[p]id="251"[p/]
در زیر نحوه ی کار روش فوق توضیح داده شده است. هنگامی که template، current_datetime.html بارگذاری می شود، موتور template به تگ {% extends %} نگاه می کند، که به این اشاره دارد که فایل مورد نظر یک template فرزند می باشد. در اینصورت موتور template به سرعت template پدر را بارگذاری می کند که در این مورد template پدر base.html می باشد.
[/p]

[p]id="252"[p/]
توجه داشته باشید که template های فرزند بلاک footer را تعریف نکرده اند، template system از مقدار مشخص شده ی بلاک درون template پدر بجای آن استفاده کرده است. مقدار مشخص شده ی درون یک تگ {% block %} در یک template پدر همیشه به صورت یک مقدار یدکی استفاده می شود.
[/p]

[p]id="253"[p/]
ارث بری تاثیری بر روی context template نخواهد داشت. به عبارت دیگر، هر template فرزند به هر یک از متغیر های template درون context دسترسی خواهد داشت.
[/p]

[p]id="254"[p/]
می توان به صورت چندین سطح از ارث بری استفاده کرد. یکی از روش های عمومی استفاده از روش ارث بری در سه سطح می باشد:
[/p]

[p]id="255"[p/]
یک template با نام base.html که بسازید که محتویات اصلی سایت را در بر بگیرد، محتویاتی که به ندرت تغییر خواهند کرد، البته اگر نگوییم هرگز تغییر نخواهند کرد.
[/p]

[p]id="256"[p/]
یک template با نام base_SECTION.html برای هر بخش از سایت خود ایجاد کنید (مانند base_photos.html و base_forum.html). این template ها باید از base.html ارث بری کنند و باید حاوی طراحی مربوط به خود باشند.
[/p]

[p]id="257"[p/]
template های هر نوع از صفحه را ایجاد کنید، مانند صفحه ی انجمن (forum) یا یک آلبوم عکس. این template ها از template مناسب مربوط به خود ارث بری کنند.
[/p]

[p]id="258"[p/]
در زیر دستور العمل های کار با ارث بری template را مشاهده می کنید:
[/p]

[ul][ul/]
[li]id="259"[li/]
در صورتیکه درون یک template از {% extends %} اسفتاده می کنید، این تگ می بایست به عنوان اولین تگ template در نظر گرفته شود، در غیر اینصورت ارث بری template کار نخواهد کرد.
[/li]

[li]id="260"[li/]
معمولاً، بهتر است از تگ های {% block %} بیشتری درون template پدر استفاده شود، بیاد داشته باشید که، template ها فرزند اجباری برای تعریف تمام block های template پدر ندارند، پس می توان هر تعداد block مناسب به صورت پیش فرض درون template پدر قرار داد، و سپس در صورت نیاز به هرکدام آن را درون template فرزند استفاده کرد.
[/li]

[li]id="261"[li/]
در صورتیکه شما تکه کدی تکراری درون تعدادی از template ها پیدا کردید، این می تواند بدین معنا باشد که شما باید آن تکه کد را به درون یک {% block %} در template پدر انتقال دهید.
[/li]

[li]id="262"[li/]
در صورتیکه نیاز به محتویات یک block درون template پدر دارید، می توانید از {{ block.super }} استفاده کرد، که یک متغیر magic می باشد که یک متن ارائه شده از template پدر را تهیه می کند. این روش در صورتیکه می خواهید بجای بازنویسی کلی یک block محتویات آن را اضافه کنید مناسب می باشد.
[/li]

[li]id="263"[li/]
نمی توان چند تگ {% block %} با نام یکسان درون یک template تعریف کرد. دلیل وجود همچین محدودیتی این است که یک block در هر دو جهت کار می کند. یک تگ block تنها یک حفره برای پر کردن، تهیه نمی کند، بلکه محتویاتی نیز برای این حفره در template پدر تعریف می کند. در صورتیکه دو block همنام درون یک template وجود داشته باشد، template پدر نخواهد دانست کدام محتویات block را استفاده کند.
[/li]

[li]id="264"[li/]
نام template ای که به {% extends %} ارسال می شود مانند [چپ]get_template()[/چپ] بارگذاری می شود. نام template به تنظیم TEMPLATE_DIRS اضافه شده است.
[/li]
[/ul]

[p]id="265"[p/]
در اغلب موارد،  آرگومانی که به {% extends %} ارسال می شود یک رشته خواهد بود، ولی این آرگومان می تواند یک متغیر نیز باشد، در صورتیکه شما نام template پدر را تا زمان اجرا نمی دانید. این خصوصیت اجازه می دهد یک حرکت پویا انجام دهید.
[/p]

[h3]id="266"«هس/»
گام بعدی
[/h3]

[p]id="267"[p/]
بسیاری از وب سایت های پیشرفته پایگاه داده محور می باشند: محتوای وب سایت درون یک پایگاه داده ی relational ذخیره شده است. این باعث یک جدا سازی تمیز بین داده و منطق برنامه خواهد شد (به همین صورت view ها و template ها باعث جداسازی منطق برنامه و نمایش برنامه می شوند.)
[/p]

[p]id="268"[p/]
فصل بعدی ابزاری را که جنگو برای تعامل با یک پایگاه داده ارائه می کند را پوشش می دهد.
[/p]
