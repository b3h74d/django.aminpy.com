[h2]«هد/»
Template های پیشرفته در جنگو 
[/h2]

[p]id="1"[p/]
اگرچه بیشتر تعامل های شما با زبان template جنگو در نقش نویسنده ی template می باشد، ولی ممکن است بخواهید موتور template را گسترش داده و آن را سفارشی کنید – یا آن را طوری ایجاد کنید که کارهایی را الان نمی تواند انجام دهد را انجام دهد، یا یا به روش دیگری کار شما را آسان تر کند.
[/p]

[p]id="2"[p/]
این فصل به عمق وجودی سیستم template جنگو خواهد پرداخت. این فصل آنچه را که نیاز می باشد برای گسترش سیستم لازم می باشد را پوشش می دهد، همچنین در صورتیکه تنها درباره ی نحوه ی کارکرد سیستم template جنگو کنجکاو می باشید می توانید در این فصل جواب سوالات خود را دریافت کنید. همچنین خصوصیت auto-escaping نیز توضیح داده خواهد شد، یک اندازه گیری امنیتی که با استفاده از آن شما دیگر تردیدی در ادامه ی استفاده از جنگو نخواهید داشت.
[/p]

[p]id="3"[p/]
در صورتیکه به دنبال استفاده از سیستم template جنگو به عنوان بخشی از برنامه ی دیگر (بدون باقی فریم ورک) هستید، بخش "پیکربندی سیستم template در حالت مستقل" کمی بعد در همین فصل را مطالعه کنید.
[/p]

[h3]id="4"«هس/»
مرور زبان Template
[/h3]

[p]id="5"[p/]
در ابتدا، اجازه دهید مروری اجمالی به تعدادی از مفاهیم معرفی شده در فصل چهارم بپردازیم:
[/p]

[ul][ul/]
[li]id="6"[li/]
template متن سند، یا یک رشته ی عادی پایتون می باشد، که با استفاده از زبان template جنگو ارتقاء پیدا کرده است.  یک template می تواند حاوی تگ و متغیر باشد.
[/li]

[li]id="7"[li/]
تگ template یک علامت داخل template می باشد که کاری را انجام می دهد.  این تعریف به طور عمدی مبهم می باشد. به عنوان مثال، تگ template می تواند یک محتوی را تولید کند، به صورت یک ساختار کنترلی (مانند عبارت if یا حلقه ی for) عمل کند، مقدار بازیابی شده از یک پایگاه داده و یا حتی قادر به دسترسی به دیگر تگ های template باشد.
[/li]

[p]id="8"[p/]
تگ های template با {% و %} پوشیده شده اند:
[/p]

[code]
{% if is_logged_in %}
    Thanks for logging in!
{% else %}
    Please log in.
{% endif %}
[/code]

[li]id="9"[li/]
متغیر یک علامت داخل یک template می باشد که یک مقدار را به عنوان خروجی بر می گرداند.
[/li]

[p]id="10"[p/]
تگ های متغیر با {{ و }} پوشیده شده اند.
[/p]

[code]
My first name is {{ first_name }}. My last name is {{ last_name }}.
[/code]

[li]id="11"[li/]
context یک نام -> مقدار مرتبط شده (همانند دیکشنری پایتون) است که به یک template ارسال می شود.
[/li]

[li]id="12"[li/]
template یک context را با جابه جا کردن متغیر با مقادیر context و اجرای تمام تگ ها render می کند.
[/li]
[/ul]

[p]id="13"[p/]
برای جزئیات بیشتر درباره ی اصول اولیه template ها به فصل چهارم مراجعه کنید.
[/p]

[p]id="14"[p/]
باقی فصل روش های گسترش دادن موتور template را بحث خواهد کرد. ابتدا، اجازه دهید برای سادگی کار نگاهی کوتاه به مسائلی که از فصل چهارم گفته نشده است بیاندازیم.
[/p]

[h3]id="15"«هس/»
RequestContext و پردازشگرهای Context
[/h3]

[p]id="16"[p/]
هنگام ارائه ی یک template، شما به یک context نیاز دارید. معمولا این یک نمونه از django.template.Context می باشد، ولی جنگو همچنین دارای یک کلاس فرزند django.template.RequestContext می باشد، که با کمی تفاوت عمل می کند. RequestContext گروهی از متغیرها را برای template context به طور پیشفرض اضافه می کند – چیزی شبیه به آبجکت HttpRequest یا اطلاعات درباره ی کاربر فعلی وارد شده به سایت.
[/p]

[p]id="17"[p/]
هنگامی که نمی خواهید مجموعه ای مشابه از متغیرها را در یک سری از template ها تعیین کنید از RequestContext استفاده می شود. برای مثال، دو view زیر را ملاحظه کنید:
[/p]

[code]
from django.template import loader, Context

def view_1(request):
    # ...
    t = loader.get_template('template1.html')
    c = Context({
        'app': 'My app',
        'user': request.user,
        'ip_address': request.META['REMOTE_ADDR'],
        'message': 'I am view 1.'
    })
    return t.render(c)

def view_2(request):
    # ...
    t = loader.get_template('template2.html')
    c = Context({
        'app': 'My app',
        'user': request.user,
        'ip_address': request.META['REMOTE_ADDR'],
        'message': 'I am the second view.'
    })
    return t.render(c)
[/code]

[p]id="18"[p/]
(توجه داشته باشید که به عمد از میانبر render_to_response() در مثال های فوق استفاده نشده است – template ها به صورت دستی بارگذاری شده اند، آبجکت ها context ساخته شده و template ها ارائه ی شده اند. تمام گام ها برای هدف به وضوح و دقت توضیح داده می شوند.)
[/p]

[p]id="19"[p/]
هر view سه متغیر یکسان – app، user و ip_address – به template خود ارسال می کند. بهتر به نظر نمی رسید اگر کدهای زائد و اضافی حذف می شدند؟
[/p]

[p]id="20"[p/]
RequestContext و پردازشگرهای context برای حل این مشکل ساخته شده اند. پردازشگرهای context، به شما اجازه می دهند، یک تعداد از متغیرها که در هر context مجموعه ای دریافت می کنند را به طور خودکار تعیین کنید – بدون اینکه مجبور باشید متغیرها را در هر فراخوانی render_to_response تعیین کنید. مشکل این است که هنگام ارائه ی یک template باید بجای Context از RequestContext استفاده کنید.
[/p]

[p]id="21"[p/]
سطح پایین ترین روش برای استفاده از پردازشگرهای context ساختن چند پردازشگر و ارسال آنها به RequestContext می باشد. در زیر نحوه ی نوشتن مثال فوق با پردازشگرهای context وجود دارد:
[/p]

[code]
from django.template import loader, RequestContext

def custom_proc(request):
    "A context processor that provides 'app', 'user' and 'ip_address'."
    return {
        'app': 'My app',
        'user': request.user,
        'ip_address': request.META['REMOTE_ADDR']
    }

def view_1(request):
    # ...
    t = loader.get_template('template1.html')
    c = RequestContext(request, {'message': 'I am view 1.'},
            processors=[custom_proc])
    return t.render(c)

def view_2(request):
    # ...
    t = loader.get_template('template2.html')
    c = RequestContext(request, {'message': 'I am the second view.'},
            processors=[custom_proc])
    return t.render(c)
[/code]

[p]id="22"[p/]
اجازه دهید کد فوق را مورد بررسی قرار دهیم:
[/p]

[ul][ul/]
[li]id="23"[li/]
ابتدا، یک تابع به نام custom_proc تعریف شده است. این تابع یک پردازشگر context می باشد که یک آبجکت HttpRequest دریافت کرده و یک دیکشنری از متغیرها برای استفاده در template context بر می گرداند. این تمام کاری است که این تابع انجام می دهد.
[/li]

[li]id="24"[li/]
دو تابع view دیگر برای استفاده از RequestContext به جای Context تغییر کرده اند. دو تفاوت در نحوه ی ساخته شدن context وجود دارد. اول، RequestContext نیاز به یک آرگومان اول برای آبجکت HttpRequest بودن می باشد که به داخل تابع view در اولین مکان ارسال شده است (request). دوم، RequestContext یک آرگومان اختیاری به نام processors دریافت می کند، که یک لیست یا تاپل از توابع پردازشگر context مورد استفاده می باشد که در کد فوق پردازشگری که در بالا تعریف کردیم را به آن ارسال کرده ایم.
[/li]

[li]id="25"[li/]
هر view دیگر لازم نیست شامل app، user یا ip_addressدر ساخت context باشد، زیرا زیرا آن ها با تابع custom_proc تهیه شده اند.
[/li]

[li]id="26"[li/]
هر view هنوز دارای انعطاف پذیری برای معرفی هر متغیر template در صورت نیاز می باشد. در این مثال، متغیر template مورد نظر یعنی message به صورت متفاوت در هر view در نظر گرفته شده است.
[/li]
[/ul]

[p]id="27"[p/]
در فصل چهارم، میانبر [چپ]render_to_response()[/چپ] معرفی شد که با استفاده از آن دیگر نیازی به فراخوانی [چپ]loader.get_template()[/چپ]، سپس ساختن یک Context و فراخوانی متد render() در template نخواهد بود. به منظور نشان دادن کار به صورت سطح پایین با پردازشگرهای context، در مثال های بالا از [چپ]render_to_response()[/چپ] استفاده نشده است، ولی امکان آن وجود دارد که از پردازشگرهای context با [چپ]render_to_response()[/چپ] استفاده شود. برای انجام این کار از آرگومان context_instance به صورت زیر استفاده می شود:
[/p]

[code]
from django.shortcuts import render_to_response
from django.template import RequestContext

def custom_proc(request):
    "A context processor that provides 'app', 'user' and 'ip_address'."
    return {
        'app': 'My app',
        'user': request.user,
        'ip_address': request.META['REMOTE_ADDR']
    }

def view_1(request):
    # ...
    return render_to_response('template1.html',
        {'message': 'I am view 1.'},
        context_instance=RequestContext(request, processors=[custom_proc]))

def view_2(request):
    # ...
    return render_to_response('template2.html',
        {'message': 'I am the second view.'},
        context_instance=RequestContext(request, processors=[custom_proc]))
[/code]

[p]id="28"[p/]
در مثال فوق کد ارائه ی هر template مربوط به view درون یک خط (شکسته شده) خلاصه شده است.
[/p]

[p]id="29"[p/]
این یک پیشرفت می باشد، ولی ارزیابی اختصار کد فوق، باید اعتراف کرد در این روش نیز تقریبا زیاده روی شده است. کدهای اضافه و زائد (متغیرهای template) به قیمت اضافه کردن کدی دیگر (فراخونی processor ها) حذف شده اند. استفاده کردن پردازشگرهای context در صورتیکه مجبور باشید هر بار processor ها را تایپ کنید شما را از تایپ کردن زیاد از حد نجات نمی دهد.
[/p]

[p]id="30"[p/]
به این دلیل، جنگو از پردازشگرهای سراسری پشتیبانی می کند. تنظیم TTEMPLATE_CONTEXT_PROCESSORS (در فایل settings.py) پردازشگرهای context ای که باید همواره برای RequestContext بکار برده شوند را طراحی می کند. این نیاز برای تعیین پردازشگرها را در هر بار که از RequestContext استفاده می کنید را حذف می کند.
[/p]

[p]id="31"[p/]
به طور پیشفرض، TEMPLATE_CONTEXT_PROCESSORS به شکل زیر خواهد بود:
[/p]

[code]
TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
)
[/code]

[p]id="32"[p/]
این تنظیم یک تاپل از آیتم های قابل فراخوانی می باشد که از یک رابط یکسان مانند تابع custom_proc که در مثال قبلی مشاهده شد استفاده می کنند – توابعی که یک آبجکت request به صورت آرگومان آن دریافت کرده و یک دیکشنری از آیتم های ادغام شده درون context بر می گرداند. توجه داشته باشید که متغیرها در TEMPLATE_CONTEXT_PROCESORS به صورت رشته مشخص شده اند، که بدین معنی می باشد که پردازشگرها لازم است جایی در مسیر پایتون باشند (بنابراین می توانید از تنظیم به آن ها مراجعه کنید).
[/p]

[p]id="33"[p/]
هر پردازشگر بدین صورت کار می کند که در صورتیکه یک پردازشگر یک متغیر به context اضافه کند و پردازشگر دوم یک متغیر با همان نام اضافه کند، دومی بر روی اولی بازنویسی می شود.
[/p]

[p]id="34"[p/]
جنگو تعدادی از پردازشگرهای ساده ی context را ارائه می دهد، از جمله آنهایی که به طور پیشفرض فعال می باشند:
[/p]

[h4]id="35"[h4/]
django.core.context_processors.auth
[/h4]

[p]id="36"[p/]
در صورتیکه TEMPLATE_CONTEXT_PROCESSORS حاوی این پردازشگر باشد، هر RequestContext حاوی این متغیرها خواهد بود:
[/p]

[ul][ul/]
[li]id="37"[li/]
user: یک نمونه ی django.auth.models.User می باشد که کاربر فعلی وارد شده (یا در صورتی کاربری وارد نشده باشد یک کاربر بی نام) را نمایش می دهد.
[/li]

[li]id="38"[li/]
messages: یک لیست از پیام ها (به صورت رشته) برای کاربر فعلی وارد شده، در پشت صحنه، این متغیر برای هر درخواست request.user.get_and_delete_messages() را فراخوانی می کند. این متد پیام های کاربر را جمع کرده و آن ها را از پایگاه داده حذف می کند.
[/li]

[li]id="39"[li/]
perms: یک نمونه از django.core.context_processors.PermWrapper که حق دسترسی هایی که کاربر فعلی وارد شده دارا می باشد را نشان می دهد.
[/li]
[/ul]

[p]id="40"[p/]
برای اطلاعات بیشتر در مورد کاربران، حق دسترسی ها و پیام ها به فصل چهاردهم مراجعه کنید.
[/p]

[h4]id="41"[h4/]
django.core.context_processors.debug
[/h4]

[p]id="42"[p/]
این پردازشگر اطلاعات اشکال زدایی (debugging) به سمت لایه ی template هدایت می کند. در صورتیکه TEMPLATE_CONTEXT_PROCESSORS حاوی این پردازشگر باشد، هر RequestContext حاوی این متغیرها خواهد بود:
[/p]

[ul][ul/]
[li]id="43"[li/]
debug: مقدار تنظیم [چپ]DEBUG (True یا False)[/چپ]. شما می توانید از این متغیر برای تست اینکه آیا در حالت debug می باشید یا خیر استفاده کنید.
[/li]

[li]id="44"[li/]
sql_queries: لیست ('sql': ..., 'time': ...) دیکشنری هایی که هر کوئری SQL نشان می دهد که دارای اتفاقاتی که تاکنون در طول درخواست رخ داده اند و چه مدت طول کشیده اند می باشد. لیست به ترتیب کوتئری هایی که صادر شده اند می باشد.
[/li]
[/ul]

[p]id="45"[p/]
بدلیل آنکه اطلاعات اشکال زدایی حساس می باشند، این پردازشگر context تنها در صورتیکه دو وضعیت زیر درست باشند متغیرها را به context اضافه می کند:
[/p]

[ul][ul/]
[li]id="46"[li/]
تنظیم DEBUG، True باشد.
[/li]

[li]id="47"[li/]
درخواست از یک آدرس IP در تنظیم INTERNAL_IPS آمده باشد.
[/li]
[/ul]

[p]id="48"[p/]
خوانندگان زیرک توجه خواهند داشته که متغیر template، debug هرگز مقدار False نخواهد داشت، زیرا در صورتیکه DEBUG مقدارش False باشد، متغیر debug در اولین مکان ساکن نخواهد بود.
[/p]

[h4]id="49"[h4/]
django.core.context_processors.i18n
[/h4]

[p]id="50"[p/]
در صورتیکه این پردازشگر فعال باشد، هر RequestContext  حاوی این متغیرها خواهد بود:
[/p]

[ul][ul/]
[li]id="51"[li/]
LANGUAGE: مقدار تنظیم LANGUAGE.
[/li]

[li]id="52"[li/]
LANUAGE_CODE: در صورت وجود request.LANGUAGE_CODE؛ در غیر اینصورت، مقدار تنظیم LANGUAGE_CODE.
[/li]
[/ul]

[h4]id="53"[h4/]
django.core.context_processors.request
[/h4]

[p]id="54"[p/]
در صورتیکه این پردازشگر فعال باشد، هر RequestContext حاوی یک متغیر request خواهد بود که آبجکت HttpRequest فعلی می باشد، توجه داشته باشید که این پردازشگر به صورت پیشفرض غیر فعال است؛ شما باید آن را فعال کنید.
[/p]

[p]id="55"[p/]
در صورتیکه template های شما نیاز به دسترسی به attribute های HttpRequest فعلی باشند مانند آدرس Ip، ممکن است از این پردازشگر استفاده کنید:
[/p]

[code]
{{ request.REMOTE_ADDR }}
[/code]

[h4]id="56"[h4/]
راهنمایی هایی برای نوشتن پردازشگرهای context خودتان
[/h4]

[p]id="57"[p/]
در زیر راهنمایی هایی برای ایجاد پردازشگر خودتان وجود دارد:
[/p]

[ul][ul/]
[li]id="58"[li/]
هر پردازشگر context را مسئول کوچکترین زیر مجموعه ی قابلیت های ممکن کنید. استفاده از پردازشگرهای چندگانه ساده می باشد، بنابراین ممکن است عمکرد را به قسمت های منطقی برای استفاده ی دوباره در آینده تقسیم کنید.
[/li]

[li]id="59"[li/]
به خاطر داشته باشید که هر پردازشگر context در TEMPLATE_CONTEXT_PROCESSORS در هر template ساخته شده با فایل تنظیمات قابل دسترس خواهد بود، بنابراین سعی کنید نام های متغیری انتخاب کنید که با نام متغیرهایی که به طور مستقل ممکن است استفاده کنید تداخل نداشته باشد. از آنجایی که نام های متغیر به حروف کوچک و بزرگ حساس می باشند، ایده ی بدی نیست که تمام متغیرهایی که یک پردازشگر تولید می کند با تماما با حروف بزرگ باشند.
[/li]

[li]id="60"[li/]
تا زمانیکه آن ها در مسیر پایتون می باشند مشکلی نیست که filesystem باشند، بنابراین می توان به آن ها از تنظیم TEMPLATE_CONTEXT_PROCESSORS اشاره کرد. با در نظر گرفتن این، مناسب آن است که آن ها را در یک فایل با نام context_processors.py داخل app یا پروژه ذخیره کرد.
[/li]
[/ul]

[h3]id="61"«هس/»
HTML Escaping خودکار
[/h3]

[p]id="62"[p/]
هنگام تولید HTML از template ها، همواره یک مخاطره وجود دارد که یک متغیر شامل کاراکترهایی باشد که بر روی نتیجه ی HTML تاثیر بگذارد. برای مثال، کد زیر را ملاحظه کنید:
[/p]

[code]
Hello, {{ name }}.
[/code]

[p]id="63"[p/]
در ابتدا، به نظر می رسد کد فوق روش بی ضرری برای نمایش نام کاربر می باشد، اما در نظر داشته باشید چه اتفاقی می افتد اگر ورودی کاربر به شکل زیر باشد:
[/p]

[code]
<script>alert('hello')</script>
[/code]

[p]id="64"[p/]
با مقدار فوق، template به صورت زیر ارائه خواهد شد:
[/p]

[code]
Hello, <script>alert('hello')</script>
[/code]

[p]id="65"[p/]
... این بدین معنی است که مرورگر یک جعبه ی خطر جاوا اسکریپت ظاهر خواهد کرد!
[/p]

[p]id="66"[p/]
به طور مشابه، چه می شود اگر name حاوی یک علامت '<' مانند زیر باشد؟
[/p]

[pre][pre/]
<b>username
[/pre]

[p]id="67"[p/]
مقدار فوق نتیجه ای به شکل زیر خواهد داشت:
[/p]

[code]
Hello, <b>username
[/code]

[p]id="68"[p/]
مقدار فوق باعث می شود، باقی کد صفحه ی وب به صورت bold نمایش داده خواهند شد!
[/p]

[p]id="69"[p/]
واضح است که، داده ی ارسال شده توسط کاربر به طور کورکورانه قابل اعتماد نمی باشد، زیرا کاربران مخرب از این حفره برای انجام مقاصد پلید استفاده کنند. این قبیل رفتار امنیتی حمله ی [چپ]Cross Site Scripting (XSS)[/چپ] نامیده می شوند. (برای اطلاعات بیشتر در مورد امنیت، به فصل بیستم مراجعه کنید.)
[/p]

[p]id="70"[p/]
جهت اجتناب از این مشکل، دو امکان وجود دارد:
[/p]

[ul][ul/]
[li]id="71"[li/]
ابتدا، می توان از طریق فیلتر escape برای اجرای هر متغیر مشکوک اطمینان حاصل کرد، به طوری که این فیلتر حروف مضر HTML را به نوع غیر مضر آن تبدیل می کند. این راهکار پیشفرض در جنگو برای سال های اول بوده است، ولی مشکل این است که این حالت توسعه دهندگان و نویسندگان template را مقید به استفاده از escape می کند. در استفاده کردن از فیلتر escape، فراموش کردن استفاده از آن بسیار اتفاق می افتد.
[/li]

[li]id="72"[li/]
دوم اینکه، می توان از HTML escaping خودکار جنگو استفاده کرد. باقی این بخش نحوه ی کار auto‑escaping را توضیح خواهد داد.
[/li]
[/ul]

[p]id="73"[p/]
به طور پیشفرض، هر template ای به صورت خودکار حروف گفته شده در خروجی هر تگ متغیر را به حروف غیر مضر تبدیل می کند. به ویژه، این پنج حروف تبدیل می شوند.
[/p]

[ul][ul/]
[li]id="74"[li/]
< به < تبدیل می شود
[/li]

[li]id="75"[li/]
> به > تبدیل می شود
[/li]

[li]id="76"[li/]
' (تک کتیشن) به &#39; تبدیل می شود
[/li]

[li]id="77"[li/]
" (دابل کتیشن) به &quot; تبدیل می شود
[/li]

[li]id="78"[li/]
& به &amp; تبدیل می شود
[/li]
[/ul]

[p]id="79"[p/]
دوباره تاکید می کنیم که، این رفتار به صورت پیشفرض می باشد. در صورتیکه از سیستم template جنگو استفاده می کنید، شما از این مشکلات محفوظ می باشید.
[/p]

[h4]id="80"[h4/]
نحوه ی از کار انداختن auto-escaping
[/h4]

[p]id="81"[p/]
در صورتیکه بخواهید حالت پیشفرض یعنی auto-escaping را برای هر وب سایت، هر سطح template و یا هر سطح متغیر، تغییر دهید، می توان به چندین روش عمل کرد.
[/p]

[p]id="82"[p/]
چرا می خواهید این حالت را تغییر دهید؟ زیرا، گاهی اوقات متغیرهای template حاوی داده ای می باشند که می خواهید به صورت HTML ارائه شوند، که در این صورت می خواهید محتویات این متغیرها escape نشوند. برای مثال، ممکن است قسمت هایی از کد HTML مورد اعتمادی را در پایگاه داده ذخیره کنید و بخواهید آن را به طور مستقیم درون template استفاده کنید. یا، ممکن است از template جنگو جهت تولید متنی به غیر از HTML استفاده کنید – مانند یک پیام پست الکترونیک برای نمونه.
[/p]

[h3]id="83"«هس/»
برای متغیرها
[/h3]

[p]id="84"[p/]
جهت غیر فعال کردن auto‑scaping برای یک متغیر، از فیلتر safe می توان استفاده کرد:
[/p]

[code]
This will be escaped: {{ data }}
This will not be escaped: {{ data|safe }}
[/code]

[p]id="85"[p/]
در مثال فوق در صورتیکه data حاوی مقدار '<b>' باشد، خروجی آن به صورت زیر خواهد بود:
[/p]

[code]
This will be escaped: <b>
This will not be escaped: <b>
[/code]

[h3]id="86"«هس/»
برای بلاک های template
[/h3]

[p]id="87"[p/]
جهت کنترل auto‑escaping برای یک template، template (یا تنها قسمتی از template) را درون تگ autoescape مانند زیر قرار دهید:
[/p]

[code]
{% autoescape off %}
    Hello {{ name }}
{% endautoescape %}
[/code]

[p]id="88"[p/]
تگ autoescape یک مقدار on یا off به صورت آرگومان دریافت می کند. گاهی اوقات می خواهید زمانی که auto‑escape در قسمتی از کد غیر فعال شده است آن را مجبور کنید که فعال شود مانند مثال زیر:
[/p]

[code]
Auto-escaping is on by default. Hello {{ name }}

{% autoescape off %}
    This will not be auto-escaped: {{ data }}.

    Nor this: {{ other_data }}
    {% autoescape on %}
        Auto-escaping applies again: {{ name }}
    {% endautoescape %}
{% endautoescape %}
[/code]

[p]id="89"[p/]
تگ auto‑escape درون template هایی که از template پدر ارث بری کرده اند نیز تاثیر می گذارد. به عنوان مثال:
[/p]

[code]
# base.html

{% autoescape off %}
<h1>{% block title %}{% endblock %}</h1>
{% block content %}
{% endblock %}
{% endautoescape %}

# child.html

{% extends "base.html" %}
{% block title %}This & that{% endblock %}
{% block content %}{{ greeting }}{% endblock %}
[/code]

[p]id="90"[p/]
به این دلیل که auto‑escaping درون template پدر غیر فعال شده است، درون template فرزند نیز غیر فعال خواهد بود، بنابراین در صورتیکه متغیر greeting حاوی رشته ی <b>Hello!</b> باشد، خروجی آن به صورت زیر خواهد بود:
[/p]

[code]
<h1>This & that</h1>
<b>Hello!</b>
[/code]

[h4]id="91"[h4/]
نکته ها
[/h4]

[p]id="92"[p/]
عموما، نویسندگان template نیازی نیست در مورد auto‑escaping خیلی زیاد نگرانی داشته باشند. توسعه دهندگان سمت پایتون (افرادی که view ها و فیلترهای سفارشی را می نویسند)، نیاز دارند، درباره ی مواردی که در داده نباید escape شوند فکر کنند، و داده را به طور مناسب علامت گذاری کنند. بنابراین کارها در template انجام خواهند شد.
[/p]

[p]id="93"[p/]
در صورتیکه یک template می سازید که ممکن است در وضعیت هایی که مطمئن نیستید آیا auto‑escaping فعال است یا خیر استفاده شده باشد، آنگاه یک فیلتر escape برای هر متغیر که نیاز به escape دارد قرار دهید. هنگامی که auto‑escaping فعال باشد، هیچ مشکلی پیش نخواهد آمد – فیلتر escape تاثیری بر روی متغیرهای auto‑escape شده نخواهد داشت.
[/p]

[h4]id="94"[h4/]
Escape کردن خودکار رشته ی خام در آرگومان های فیلتر
[/h4]

[p]id="95"[p/]
همانطور که پیش تر ذکر شد، آرگومان های فیلتر می توانند رشته باشند:
[/p]

[code]
{{ data|default:"This is a string literal." }}
[/code]

[p]id="96"[p/]
تمام رشته های خام بدون هیچ escape خودکاری درون template مندرج شده می باشند – آن ها مثل اینکه از میان فیلتر safe عبور کرده باشند عمل می کنند. دلیل این موضوع این است که نویسنده ی template آنچه را که به صورت رشته ی خام می آید را تحت کنترل دارد، بنابراین آن ها اطمینان حاصل می کنند که متن هنگامی template نوشته می شود به صورت صحیح escape شده باشد.
[/p]

[p]id="97"[p/]
این بدان معناست که خواهید نوشت:
[/p]

[code]
{{ data|default:"3 &amp;lt; 2" }}
[/code]

[p]id="98"[p/]
... به جای
[/p]

[code]
{{ data|default:"3 < 2" }}  <-- Bad! Don't do this.
[/code]

[p]id="99"[p/]
حالت فوق تاثیری بر روی مقداری که درون خود متغیر می باشد نخواهد داشت. در صورت لزوم محتویات متغیرها همچنان به طور خودکار escpae شده می باشند،  زیرا این دیگر خارج از کنترل نویسنده ی template می باشد.
[/p]

[h3]id="100"«هس/»
بارگذاری داخل Template 
[/h3]

[p]id="101"[p/]
عموما، شما template ها را در فایل هایی درون filesystem خود ذخیره خواهید کرد، اما می توان از template loader های سفارشی برای بارگذاری template ها از منابع دیگر استفاده کرد.
[/p]

[p]id="102"[p/]
جنگو دارای دو روش برای بارگذاری template می باشد:
[/p]

[ul][ul/]
[li]id="103"[li/]
django.template.loader.get_template (template_name): get_template، template کامپایل شده (یک آبجکت Template) برای template با نام داده شده را بر می گرداند. در صورتیکه template مورد نظر وجود نداشته باشد، خطای TemplateDoesNotExist رخ خواهد داد.
[/li]

[li]id="104"[li/]
django.template.loader.select_template (template_name_list): select_template درست مثل get_template می باشد، با این تفاوت که select_template لیستی از نام template ها را دریافت می کند. از لیست موجود، اولین template موجود را بر می گرداند. در صورتیکه هیچکدام از template ها وجود نداشته باشند، یک خطای TemplateDoesNotexist رخ خواهد داد.
[/li]
[/ul]

[p]id="105"[p/]
همانطور که در فصل چهارم بحث شد، هر کدام از این توابع به صورت پیشفرض برای بارگذاری template ها از تنظیم TEMPLATE_DIRS استفاده می کنند. 
[/p]

[p]id="106"[p/]
بعضی از loader ها به طور پیشفرض غیر فعال می باشند، ولی می توان با ویرایش تنظیم TEMPLATE_LOADER آن ها را فعال کرد. TEMPLATE_LOADERS باید یک تاپل از رشته ها باشد، به طوری که هر رشته یک template loader را نمایش می دهد. این template loader ها به همراه جنگو ارائه شده اند:
[/p]

[ul][ul/]
[li]id="107"[li/]
django.template.loaders.filesystem.load_template_source: این loader، template ها را از filesystem به همراه TEMPLATE_DIRS بارگذاری می کند.
[/li]

[li]id="108"[li/]
django.template.loaders.app_directories.load_template_source: این loader، template ها را از برنامه های جنگو روی filesystem بارگذاری می کند. برای هر برنامه در INSTALLED_APPS، loader یک دایرکتوری زیرمجموعه ی templates را جستجو می کند. در صورتیکه دایرکتوری وجود داشته باشد، جنگو در آن جا به دنبال template ها می گردد.
[/li]

[p]id="109"[p/]
این بدین معناست که می توان template ها را با برنامه های فردی خودتان ذخیره کنید، برای مثال، اگر INSTALLED_APPS حاوی ('myproject.polls'، 'myproject.music') باشد، در اینصورت get_template('foo.html') به شکل زیر template ها را بدین ترتیب جستجو می کند:
[/p]
[li]id="110"[li/]
/path/to/myproject/polls/templates/foo.html
[/li]

[li]id="111"[li/]
/path/to/myproject/music/templates/foo.html
[/li]

[p]id="112"[p/]
توجه داشته باشید که loader یک بهینه سازی را اجرا می کند: loader یک لیست از پکیج های INSTALLED_APPS را که دارای دایرکتوری زیرمجموعه ی templates می باشد را cache می کند.
[/p]

[p]id="113"[p/]
این loader به صورت پیشفرض فعال می باشد.
[/p]

[li]id="114"[li/]
django.template.loaders.eggs.load_template_source: این loader درست مثل app_directories می باشد، با این تفاوت که template ها را به جای filesystem از egg های پایتون بارگذاری می کند. این loader به طور پیشفرض غیر فعال می باشد؛ در صورتیکه از egg ها برای توزیع برنامه ی خود استفاده می کنید نیاز خواهید داشت که آن را فعال کنید. (egg های پایتون روشی برای فشرده سازی کد پایتون داخل یک فایل تنها می باشد.)
[/li]
[/ul]

[p]id="115"[p/]
جنگو به منظور توجه به تنظیم TEMPLATE_LOADERS از template loader ها استفاده می کند. جنگو از هر loader تا پیدا کردن مطابق آن استفاده می کند.
[/p]

[h3]id="116"«هس/»
گسترش Template System
[/h3]

[p]id="117"[p/]
اکنون که کمی بیشتر درباره ی مسائل داخلی template system فهمیده اید، اجازه دهید نحوه ی گسترش سیستم با کد سفارشی را مورد بررسی قرار دهیم.
[/p]

[p]id="118"[p/]
بیشترین نقش سفارشی سازی template فرمی از تگ های سفارشی و فیلترها می باشد. اگر چه زبان template جنگو دارای بسیاری از تگ ها و فیلترهای داخلی می باشد، شما احتمالا کتابخانه هایی از تگ ها و فیلترهای خودتان را جمع آوری خواهید کرد تا احتیاجات خودتان را رفع کنید. خوشبختانه، تعریف عملکرد برنامه برای خودتان بسیار آسان می باشد.
[/p]

[h4]id="119"[h4/]
ساختن یک کتابخانه ی Template
[/h4]

[p]id="120"[p/]
برای نوشتن تگ ها یا فیلترهای سفارشی، اولین کار ساختن یک کتابخانه ی template است – قسمت کوچکی از زیر ساخت جنگو که می تواند دوباره استفاده شود.
[/p]

[p]id="121"[p/]
ساختن یک کتابخانه ی template دارای یک روند دو مرحله ای می باشد:
[/p]

[ul][ul/]
[li]id="122"[li/]
مرحله ی اول، تصمیم گرفتن اینکه کدام برنامه ی جنگو باید به کتابخانه ی template جا دهد. در صورتیکه از طریق دستور manage.py startapp، یک app ساخته اید، می توانید کتابخانه ی خود را در آنجا قرار دهید، یا می توانید منحصرا یک app دیگر برای کتابخانه ی template بسازید. ما ساختن یک app جدا برای کتابخانه ی template را پیشنهاد می کنیم، زیرا فیلترهای شما می توانند در پروژه های آینده نیز برای شما مفید واقع شوند.
[/li]

[p]id="123"[p/]
هر روشی را که انتخاب می کنید، اطمینان حاصل کنید که app مورد نظر را به تنظیم INSTALLED_APPS اضافه کرده اید. به طور کوتاه این موضوع را توضیح خواهیم داد.
[/p]

[li]id="124"[li/]
مرحله ی دوم، ساختن یک دایرکتوری به نام templatetags در پکیج مناسب برنامه ی جنگو می باشد. این دایرکتوری باید از نظر مسیر هم سطح با models.py، views.py و غیره باشد. برای مثال:
[/li]

[pre][pre/]
books/
    __init__.py
    models.py
    templatetags/
    views.py
[/pre]

[p]id="125"[p/]
دو فایل خالی در دایرکتوری templatetags بسازید: یک فایل __init__.py (برای اینکه به پایتون نشان داده شود که این یک پکیج حاوی کد پایتون می باشد) و یک فایل که حاوی تعریف تگ ها/فیلترهای سفارشی شما خواهد بود. نام فایل دوم آن چیزی خواهد بود که شما برای بارگذاری تگ ها از آن استفاده خواهید کرد. برای مثال، در صورتیکه تگ ها یا فیلترهای سفارشی شما درون فایلی به نام poll_extras.py خواهد بود، شما کدی نظیر کد زیر را درون template خواهید داشت:
[/p]

[code]
{% load poll_extras %}
[/code]

[p]id="126"[p/]
تگ {% load %} تنظیم INSTALLED_APPS را مورد بررسی قرار داده و تنها اجازه به بارگذاری کردن کتابخانه های template داخل برنامه های نصب شده جنگو می دهد. این یک ویژگی امنیتی می باشد؛ این ویژگی اجازه می دهد تا مکانی برای بسیاری از کتابخانه های template در یک رایانه ی تنها را بدون فعال کردن دسترسی به تمام آنها برای هر نصب جنگو ایجاد کنید.
[/p]
[/ul]

[p]id="127"[p/]
در صورتیکه یک کتابخانه ی template نوشته اید که به هیچ models/views ای مرتبط نیست، این حالت برای داشتن پکیج برنامه ی جنگو که حاوی تنها یک پکیج templatetags می باشد معتبر و کاملا عادی است. هیچ محدودیتی نسبت به تعداد ماژول هایی که شما در پکیج templatetags قرار می دهید وجود ندارد. تنها به خاطر داشته باشید که یک عبارت {% load %} تگ ها یا فیلترهایی برای نام ماژول پایتون داده شده بارگذاری خواهد کرد، نه نام برنامه.
[/p]

[p]id="128"[p/]
هنگامی که آن ماژول پایتون را ساخته باشید، تنها ملزم به نوشتن مقدار کمی از کد پایتون بسته به اینکه آیا چه فیلتر یا تگی می نویسید خواهید بود.
[/p]

[p]id="129"[p/]
برای معتبر بودن کتابخانه ی تگ، ماژول باید حاوی یک متغیر در سطح ماژول به نام register باشد که یک نمونه از template.Library می باشد. این یک ساختار داده می باشد که تمام تگ ها و فیلترها درون آن عضو شده اند. بنابراین، در بالا ماژول، کد زیر را اضافه کنید:
[/p]

[code]
from django import template

register = template.Library()
[/code]

[note]
نکته
[note/]

[p]id="130"[p/]
برای یک انتخاب خوب از مثال ها، کد منبع فیلترها و تگ های پیشفرض جنگو را بخوانید. آن ها به ترتیب در django/template/defaultfilters.py و django/template/defaulttags.py می باشند. همچنین برخی برنامه های موجود در django.contrib حاوی کتابخانه های template می باشد.
[/p]
[/note]

[p]id="131"[p/]
هنگامی که متغیر register را ساختید، شما برای ساختن فیلترها و تگ ها template از آن استفاده خواهید کرد.
[/p]

[h4]id="132"[h4/]
نوشتن فیلترهای سفارشی Template
[/h4]

[p]id="133"[p/]
فیلترهای سفارشی تنها توابع پایتون می باشند که یک یا دو آرگومان دریافت می کنند:
[/p]

[ul][ul/]
[li]id="134"[li/]
مقدار متغیر (ورودی)
[/li]

[li]id="135"[li/]
مقدار آرگومان، که می تواند یک مقدار پیشفرض یا داشته و یا رو هم رفته ترک شده باشد
[/li]
[/ul]

[p]id="136"[p/]
برای مثال، در فیلتر {{ var|foo:"bar" }}، فیلتر foo محتویات متغیر var و آرگومان "bar" را ارسال خواهد کرد.
[/p]

[p]id="137"[p/]
توابع فیلتر باید همواره چیزی را بر گردانند. آن نباید خطایی ایجاد کنند، و باید به آرامی خطاها را رد کنند. در صورتیکه یک خطا وجود داشته باشد، یا باید ورودی اصلی را برگردانند یا یک رشته ی خالی را، هر کدام که حساسیت بیشتری خواهد داشت.
[/p]

[p]id="138"[p/]
در اینجا یک مثال از تعریف فیلتر را ملاحظه می کنید:
[/p]

[code]
def cut(value, arg):
    "Removes all values of arg from the given string"
    return value.replace(arg, '')
[/code]

[p]id="139"[p/]
در زیر نحوه ی استفاده حذف کردن فاصله های مقدار یک متغیر توسط فیلتر بالا نشان داده شده است:
[/p]

[code]
{{ somevariable|cut:" " }}
[/code]

[p]id="140"[p/]
اغلب فیلترها آرگومانی دریافت نمی کنند. در این مورد، تنها آرگومان تابع را حذف کنید:
[/p]

[code]
def lower(value): # Only one argument.
    "Converts a string into all lowercase"
    return value.lower()
[/code]

[p]id="141"[p/]
هنگامی که تعریف فیلتر خود را نوشتید، برای اینکه آن را برای زبان template جنگو در دسترس قرار دهید لازم است که آن رابه نمونه ی Library خود معرفی کنید: 
[/p]

[code]
register.filter('cut', cut)
register.filter('lower', lower)
[/code]

[p]id="142"[p/]
متد [چپ]Library.filter()[/چپ] دو آرگومان دریافت می کند:
[/p]

[ul][ul/]
[li]id="143"[li/]
نام فیلتر (یک رشته)
[/li]

[li]id="144"[li/]
خود تابع فیلتر
[/li]
[/ul]

[p]id="145"[p/]
در صورتیکه از پایتون 2.4 یا بالاتر استفاده می کنید، می توانید بجای روش فوق از regiser.filter() به صورت یک decorator استفاده کنید:
[/p]

[code]
@register.filter(name='cut')
def cut(value, arg):
    return value.replace(arg, '')

@register.filter
def lower(value):
    return value.lower()
[/code]

[p]id="146"[p/]
در صورتیکه آرگومان name را قرار ندهید، همانطور که در مثال دوم مشاهده کردید، جنگو از نام تابع به صورت نام فیلتر استفاده خواهد کرد.
[/p]

[p]id="147"[p/]
مثال فوق نیز مثال کامل کتابخانه ی template یعنی تهیه ی فیلتر cut می باشد:
[/p]

[code]
from django import template

register = template.Library()

@register.filter(name='cut')
def cut(value, arg):
    return value.replace(arg, '')
[/code]

[h4]id="148"[h4/]
توشتن تگ های template سفارشی
[/h4]

[p]id="149"[p/]
تگ ها پیچیده تر از فیلترهای می باشند، زیرا تقریبا هرکاری را می توانند انجام دهند.
[/p]

[p]id="150"[p/]
فصل چهارم نحوه ی کار سیستم template جنگو را در یک روند دو مرحله ای توضیح می دهد: کامپایل و ارائه (compling and rendering). برای تعریفی یک تگ template سفارشی، لازم است نحوه ی مدیریت هر دو مرحله ی فوق در زمانی که جنگو تگ شما را به دست می آورد به آن گفته شود.
[/p]

[p]id="151"[p/]
هنگامی که جنگو یک template را کامپایل می کند، متن خام template را به note هایی تقسیم می کند. هر node یک نمونه از django.template.Node بوده و دارای یک متد [چپ]render()[/چپ] می باشد. در نتیجه، یک template کامپایل شده یک لیست از آبجکت های Node می باشد. برای مثال، template زیر را ملاحظه کنید:
[/p]

[code]
Hello, {{ person.name }}.

{% ifequal name.birthday today %}
    Happy birthday!
{% else %}
    Be sure to come back on your birthday
    for a splendid surprise message.
{% endifequal %}
[/code]

[p]id="152"[p/]
در حالت کامپایل شدهه ی template، template فوق به صورت لیستی از node های زیر نشان داده شده است:
[/p]

[ul][ul/]
[li]id="153"[li/]
node متن: "Hello, "
[/li]

[li]id="154"[li/]
node متغیر: person.name
[/li]

[li]id="155"[li/]
node متن: ".\n\n"
[/li]

[li]id="156"[li/]
ifEqual node: name.birthday and today
[/li]
[/ul]

[p]id="157"[p/]
هنگامی که در یک template کامپایل شده [چپ]render()[/چپ] فراخوانی می شود، template متد [چپ]render()[/چپ] در هر Node موجود در لیست node را با context داده شده فراخوانی می کند. نتیجه ی کار برای شکل دادن به خروجی template همه ی node های وصل شده به یکدیگر است. در نتیجه، برای تعریف یک تگ template سفارشی، شما نحوه ی تبدیل شدن تگ خام template به یک Node (کامپایل تابع) و آنچه را که متد [چپ]render()[/چپ] ند انجام می دهد را تعیین می کنید.
[/p]

[p]id="158"[p/]
بخش های بعدی، تمامی مراحل نوشتن تگ سفارشی پوشش داده خواهد شد.
[/p]

[h4]id="159"[h4/]
نوشتن کامپایل تابع
[/h4]

[p]id="160"[p/]
برای هر تگ template ای که parser با آن مواجه است، یک تابع پایتون با محتویات تگ و خود آبجکت parser فراخوانی می شود. این تابع موظف است یک نمونه Node بر اساس محتویات تگ بر گرداند.
[/p]

[p]id="161"[p/]
برای مثال، اجازه دهید یک تگ template بنویسیم، {% current_time %}، که زمان/تاریخ فعلی را نمایش دهد، که قالب بندی آن نیز بر حسب پارامتر داده شده در تگ در strftime (http://www.djangoproject.com/r/python/strftime/ را مشاهده کنید) باشد. در این مورد تصور می کنیم تگ باید به شکل زیر استفاده شود: 
[/p]

[code html]
[/p]
[/code]

[note]
نکته
[note/]

[p]id="163"[p/]
بله، این تگ template یک تگ اضافه و زائد می باشد – تگ پیشفرض {% now %} با روشی ساده تر همین کار را انجام می دهد. تگ template فوق تنها با هدف آشنایی با ساختن تگ های سفارشی  ارائه شده است.
[/p]
[/note]

[p]id="164"[p/]
parser برای این تابع پارامتر را دریافت کرده و یک آبجکت Node بسازد:
[/p]

[code]
from django import template

register = template.Library()

def do_current_time(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, format_string = token.split_contents()
    except ValueError:
        msg = '%r tag requires a single argument' % token.split_contents()[0]
        raise template.TemplateSyntaxError(msg)
    return CurrentTimeNode(format_string[1:-1])
[/code]

[p]id="165"[p/]
اجازه دهید کد فوق را مورد بررسی قرار دهیم:
[/p]

[ul][ul/]
[li]id="166"[li/]
هر کامپایل تابع تگ template دو آرگومان دریافت می کند، parser و token. parser آبجکت template parser می باشد که در این مثال از آن استفاده نشده است. token علامتی است که در حال حاضر توسط parser تجزیه شده است.
[/li]

[li]id="167"[li/]
token.contents یک رشته از محتویات خام تگ می باشد. در مثال فوق 'current_time "%Y‑%m‑%d %I:%M %p"' می باشد.
[/li]

[li]id="168"[li/]
متد [چپ]token.split_contents()[/چپ] بر حسب فاصله، تا زمانی که متن توسط کتیشن پوشیده شده است آن را جدا می کند. از [چپ]token.contents.split()[/چپ] استفاده نکنید () در دست ترجمه ...
[/li]

[li]id="169"[li/]
تابع فوق موظف است خطای django.template.TemplateSyntaxError با یک پیام مفید برای هر خطا ایجاد کند.
[/li]

[li]id="170"[li/]
نام تگ را به طور مستقیم در پیام های خطا استفاده نکنید، زیرا این کار باعث می شود نام تگ به تابع شما وصل شود. token.split_contents()[0] همواره نام تگ شما خواهد بود – حتی هنگامی که تگ دارای هیچ آرگومانی نیست.
[/li]

[li]id="171"[li/]
تابع فوق یک CurrentTimeNode (که کمی بعد آن را ایجاد خواهیم کرد) حاوی هرچیزی که node برای شناختن این تگ نیاز دارد بر می گرداند. در این مورد، تنها آرگومان "%Y‑%m‑%d %I:%M %p" ارسال می شود. کتیشن عقبی و جلویی تگ template توسط format_string[1:-1] حذف می شود.
[/li]

[li]id="172"[li/]
توابع کامپایل تگ template باید یک کلاس فرزند Node بر گردانند؛ در غیر اینصورت مقدار برگشتی یک خطا است.
[/li]
[/ul]

[h4]id="173"[h4/]
نوشتن Template Node
[/h4]

[p]id="174"[p/]
گام بعدی در نوشتن تگ های سفارشی، تعریف یک کلاس فرزند Node که حاوی یک متد render() است می باشد. در ادامه ی مثال قبلی، نیاز به تعریف CurrentTimeNode می باشد:
[/p]

[code]
import datetime

class CurrentTimeNode(template.Node):
    def __init__(self, format_string):
        self.format_string = str(format_string)

    def render(self, context):
        now = datetime.datetime.now()
        return now.strftime(self.format_string)
[/code]

[p]id="175"[p/]
این دو تابع ([چپ]__init__()[/چپ] و [چپ]render()[/چپ]) به طور مستقیم به دو مرحله ی در روند [چپ]template (compilation and rendering)[/چپ] مرتبط هستند. در نتیجه، تابع [چپ]__init__()[/چپ] تنها ملزم به ذخیره ی قالب رشته ی برای استفاده ی بعدی می باشد، و تابع [چپ]render()[/چپ] کار واقعی را انجام می دهد.
[/p]

[p]id="176"[p/]
مانند فیلترهای template، این توابع باید به جای ایجاد خطا به طور بی صدا خطاهای ایجاد شده را رد کنند. تنها زمانی که تگ های template اجازه دارند خطاها را ایجاد کنند زمان کامپایل می باشد.
[/p]

[h4]id="177"[h4/]
معرفی تگ
[/h4]

[p]id="178"[p/]
در پایان، نیاز به معرفی تگ با نمونه ی ماژول Library می باشد. معرفی تگ های سفارشی بسیار شبیه به معرفی فیلترهای سفارشی (همانطور که توضیح داده شد) می باشد. تنها یک نمونه template.Library را معرفی کرده و متد tag() آن را فراخوانی کنید. برای مثال:
[/p]

[code]
register.tag('current_time', do_current_time)
[/code]

[p]id="179"[p/]
متد tag() دو آرگومان دریافت می کند:
[/p]

[ul][ul/]
[li]id="180"[li/]
نام تگ template (رشته).
[/li]

[li]id="181"[li/]
تابع کامپایل.
[/li]
[/ul]

[p]id="182"[p/]
همانند معرفی فیلتر، امکان این وجود دارد که از register.tag به صورت یک decorator در پایتون 2.4 و بالاتر استفاده کرد:
[/p]

[code]
@register.tag(name="current_time")
def do_current_time(parser, token):
    # ...

@register.tag
def shout(parser, token):
    # ...
[/code]

[p]id="183"[p/]
در صورت حذف آرگومان name، همانند مثال دوم، جنگو از نام تابع برای نام تگ استفاده خواهد کرد.
[/p]

[h4]id="184"[h4/]
تنظیم یک متغیر در Context
[/h4]

[p]id="185"[p/]
مثال بخش قبلی به سادگی یک مقدار را بر می گرداند. خیلی اوقات قرار دادن متغیرها به جای برگشت دادن مقادیر  مفید خواهد بود. در این روش، نویسندگان template می توانند تنها متغیرهایی که تگ های template شما قرار داده اند را استفاده کنند.
[/p]

[p]id="186"[p/]
برای قرار دادن یک متغیر در context، از اختصاص دادن دیکشنری برای آبجکت context در متد render() استفاده می شود. در زیر نسخه ی تغییر کرده ی CurrentTimeNode مشاهده می کنید:
[/p]

[code]
class CurrentTimeNode2(template.Node):
    def __init__(self, format_string):
        self.format_string = str(format_string)

    def render(self, context):
        now = datetime.datetime.now()
        context['current_time'] = now.strftime(self.format_string)
        return ''
[/code]

[p]id="187"[p/]
(ساختن یک تابع do_current_time2، به اضافه ی معرفی آن تابع به تگ template، current_time2 انجام نشده است، تا خواننده آن ها را به عنوان تمرین انجام داد.)
[/p]

[p]id="188"[p/]
توجه داشته باشید که render() یک رشته ی خالی را بر می گرداند. render() همواره باید یک رشته بر گرداند، بنابراین در صورتیکه تمام تگ های template یک متغیر را قرار دهند، render() باید یک رشته ی خالی بر گرداند.
[/p]

[p]id="189"[p/]
در اینجا نحوه ی استفاده ی نسخه ی جدید از تگ نشان داده شده است:
[/p]

[code html]
{% current_time2 "%Y-%M-%d %I:%M %p" %}
[/p]
[/code]

[p]id="191"[p/]
ولی یک مشکل با CurrentTimeNode2 وجود دارد: نام متغیر current_time به صورت مستقیم استفاده شده است. این بدان معناست که شما نیاز است اطمینان حاصل کنید که template شما از {{ current_time }} هیچ جای دیگری استفاده نکرده است، زیرا {% current_time2 %} مقدار آن متغیر را باز نویسی خواهد کرد.
[/p]

[p]id="192"[p/]
راهکار درست این است که تگ template نامی برای متغیر قرار داده شده تعیین نماید:
[/p]

[code html]
{% get_current_time "%Y-%M-%d %I:%M %p" as my_current_time %}
[/p]
[/code]

[p]id="194"[p/]
برای انجام چنین کاری، نیاز به تغییر هر دو تابع کامپایل و کلاس Node به صورت زیر می باشد:
[/p]

[code]
import re

class CurrentTimeNode3(template.Node):
    def __init__(self, format_string, var_name):
        self.format_string = str(format_string)
        self.var_name = var_name

    def render(self, context):
        now = datetime.datetime.now()
        context[self.var_name] = now.strftime(self.format_string)
        return ''

def do_current_time(parser, token):
    # This version uses a regular expression to parse tag contents.
    try:
        # Splitting by None == splitting by spaces.
        tag_name, arg = token.contents.split(None, 1)
    except ValueError:
        msg = '%r tag requires arguments' % token.contents[0]
        raise template.TemplateSyntaxError(msg)

    m = re.search(r'(.*?) as (\w+)', arg)
    if m:
        fmt, var_name = m.groups()
    else:
        msg = '%r tag had invalid arguments' % tag_name
        raise template.TemplateSyntaxError(msg)

    if not (fmt[0] == fmt[-1] and fmt[0] in ('"', "'")):
        msg = "%r tag's argument should be in quotes" % tag_name
        raise template.TemplateSyntaxError(msg)

    return CurrentTimeNode3(fmt[1:-1], var_name)
[/code]

[p]id="195"[p/]
حالا do_current_time() قالب رشته و نام متغیر را به CurrentTimeNode3 ارسال می کند.
[/p]

[h4]id="196"[h4/]
Parse کردن تا تگ Template دیگر
[/h4]

[p]id="197"[p/]
تگ های template می توانند به صورت بلاک های حاوی تگ های دیگر (مانند {% if %} و {% for %}) کار کنند. برای ساختن یک تگ template مانند این، در تابع کامپایل خود از parser.parse() استفاده کنید.
[/p]

[p]id="198"[p/]
در زیر نحوه ی کار تگ {% comment %} انجام شده است:
[/p]

[code]
def do_comment(parser, token):
    nodelist = parser.parse(('endcomment',))
    parser.delete_first_token()
    return CommentNode()

class CommentNode(template.Node):
    def render(self, context):
        return ''
[/code]

[p]id="199"[p/]
parser.parse() یک تاپل از نام تگ های template برای استفاده داخل تگ دریافت می کند و یک نمونه از django.template.NodeList بر می گرداند، که لیست تمام آبجکت های Node ای می باشد که parser با آن ها قبل از برخورد با نام تگ موجود در تاپل برخورد کرده است.
[/p]

[p]id="200"[p/]
بنابراین در مثال قبلی، nodelist یک لیست از تمام node های بین {% comment %} و {% endcomment %} بدون در نظر گرفتن خود آن ها می باشد.
[/p]

[p]id="201"[p/]
بعد از آن که parser.parse() فراخوانی شده است، parser در دست ترجمه ...
[/p]

[p]id="202"[p/]
سپس CommentNode.render() به سادگی یک رشته ی خالی را بر می گرداند. هر چیزی بین {% comment %} و {% endcomment %} رد شده است.
[/p]

[h4]id="203"[h4/]
Parse کردن تا تگ Template دیگر و ذخیره ی محتویات
[/h4]

[p]id="204"[p/]
در مثال قبلی، do_comment هر چیزی را بین {% comment %} و {% endcomment %} رد کرد. همچنین این امکان وجود دارد که با کد بین تگ های template کاری انجام داد.
[/p]

[p]id="205"[p/]
برای مثال، در اینجا یک تگ template سفارشی، {% upper %}، که هر چیزی بین خودش و {% endupper %} را به حروف بزرگ تبدیل می کند:
[/p]

[code html]
{% upper %}
    This will appear in uppercase, {{ user_name }}.
{% endupper %}
[/code]

[p]id="206"[p/]
همانند مثال قبلی، از parser.parse() استفاده کرده ایم. این بار، نتیجه ی nodelist را به Node ارسال کرده ایم:
[/p]

[code]
def do_upper(parser, token):
    nodelist = parser.parse(('endupper',))
    parser.delete_first_token()
    return UpperNode(nodelist)

class UpperNode(template.Node):
    def __init__(self, nodelist):
        self.nodelist = nodelist

    def render(self, context):
        output = self.nodelist.render(context)
        return output.upper()
[/code]

[p]id="207"[p/]
تنها مفهوم جدید در کد فوق self.nodelist.render(context) در UpperNode.render() می باشد که به سادگی برای هر Node در لیست node متد render() فراخوانی شده است.
[/p]

[p]id="208"[p/]
برای مثال های بیشتر از ارائه ی پیچیده، کد منبع {% if %}، {% for %}، {% ifequal %} و {% ifchanged %} را مشاهده کنید. این تگ ها در django/template/defaulttags.py موجود می باشند.
[/p]

[h4]id="209"[h4/]
میانبر برای تگ های ساده
[/h4]

[p]id="210"[p/]
بسیاری از تگ های template یک آرگومان تنها دریافت می کنند – یک رشته یا یک مرجع متغیر template – و یک رشته را بعد از انجام برخی پردازش های منحصرا بر روی آرگومان ورودی و برخی اطلاعات خارجی بر می گردانند. برای مثال، تگ current_time ای که قبلا نوشته شد. یک قالب رشته به آن داده شد، و current_time زمان را به صورت یک رشته بر گرداند.
[/p]

[p]id="211"[p/]
جهت ساده کردن ساختن این قبلی تگ ها، جنگو یک تابع کمک کننده ارائه می کند، simple_tag. این تابع یک متد از django.template.Library می باشد که یک تابع که آن هم یک آرگومان قبول می کند دریافت می کند، کار این تابع پیچیدن در تابع render و کارهای ضروری می باشد که قبلا ذکر شده است مانند معرفی کردن را با template system انجام می دهد.
[/p]

[p]id="212"[p/]
تابع current_time را با حالت نوشته شده ی فوق در زیر مشاهده می کنید:
[/p]

[code]
def current_time(format_string):
    try:
        return datetime.datetime.now().strftime(str(format_string))
    except UnicodeEncodeError:
        return ''

register.simple_tag(current_time)
[/code]

در پایتون 2.4 و بالاتر، می توان از decorator استفاده کرد:

[code]
@register.simple_tag
def current_time(token):
    # ...
[/code]

[p]id="213"[p/]
توجه به چند نکته ضروری می باشد:
[/p]

[ul][ul/]
[li]id="214"[li/]
تنها یک آرگومان (تک) داخل تابع ما ارسال شده است.
[/li]

[li]id="215"[li/]
بررسی برای تعداد آرگومان های مورد به وسیله تعداد فراخوانی تابع انجام شده است، بنابراین نیازی به انجام آن نیست.
[/li]

[li]id="216"[li/]
کتیشن اطراف آرگومان (در صورت وجود) حذف شده است، بنابراین ما یک رشته ی یونیکد عادی دریافت می کنیم.
[/li]
[/ul]

[h4]id="217"[h4/]
تگ های Inclusion
[/h4]

[p]id="218"[p/]
تگ template رایج دیگر نوعی است که برخی داده ها را از طریق ارائه ی template دیگر نمایش می دهد. برای مثال، رابط مدیر جنگو از تگ های template سفارشی برای نمایش دکمه ها زیر فرم صفحات "add/change" استفاده می کند. آن دکمه های همواره دارای ظاهر یکسان می باشند، ولی نشانه های لینک بسته به ویرایش آبجکت تغییر می کند. آن ها یک مورد عالی برای استفاده از یک template کوچک می باشد که با جزئیات فرم آبجکت فعلی پر شده اند.
[/p]

[p]id="219"[p/]
این قبیل از تگ ها، تگ های inclusion نامیده می شوند. نوشتن تگ های inclusion بهتر موضوعات دیگر با مثال قابل نشان دادن است. اجازه دهید یک تگ بنویسیم که یک لیست از کتاب ها برای یک آبجکت Author داده شده تولید می کند. ما از تگ به صورت زیر استفاده می کنیم:
[/p]

[code]
{% books_for_author author %}
[/code]

[p]id="220"[p/]
نتیجه چیزی شبیه به کد زیر خواهد بود:
[/p]

[code html]
<ul>
    <li>The Cat In The Hat</li>
    <li>Hop On Pop</li>
    <li>Green Eggs And Ham</li>
</ul>
[/code]

[p]id="224"[p/]
ابتدا، تابعی تعریف می شود که آرگومانی دریافت کرده و یک دیکشنری از داده ها برای نتیجه تولید کند. تقدت داشته باشید که نیاز به برگرداندن تنها یک دیکشنری می باشد، نه چیز پیچیده تر دیگری. این به صورت context برای قطعه ی template استفاده شده است:
[/p]

[code]
def books_for_author(author):
    books = Book.objects.filter(authors__id=author.id)
    return {'books': books}
[/code]

[p]id="225"[p/]
در قدم بعدی، template ای با استفاده جهت ارائه ی خروجی تگ ساخته می شود. مثال زیر، template ای بسیار ساده می باشد:
[/p]

[code]
<ul>
    {% for book in books %}
        </li>
    {% endfor %}
</ul>
[/code]

[p]id="227"[p/]
در پایان، تگ inclusion با استفاده از فراخوانی متدinclusion_tag() در یک آبجکت Library ساخته و معرفی می شود.
[/p]

[p]id="228"[p/]
مثال زیر، در صورتیکه template قبلی در یک فایل با نام book_snipper.html باشد، به صورت زیر معرفی می شود:
[/p]

[code]
register.inclusion_tag('book_snippet.html')(books_for_author)
[/code]

[p]id="229"[p/]
همچنین در پایتون 2.4 به بالا می توان به شکل زیر نیز کار کرد:
[/p]

[code]
@register.inclusion_tag('book_snippet.html')
def books_for_author(author):
    # ...
[/code]

[p]id="230"[p/]
گاهی اوقات، تگ های inclusion شما نیاز به دسترسی به مقادیری از context مربوط به template پدر دارد. برای حل این موضوع، جنگو یک انتخاب takes_context را برای تگ ها inclusion ارائه کرده است. در صورتیکه در ساختن یک تگ inclusion از takes_context استفاده کنید، تگ آرگومان های الزامی نخواهد داشت، و تابع زیرین پایتون یک آرگومان خواهد داشت: template context تا زمانیکه تگ فراخوانی شده بود.
[/p]

[p]id="231"[p/]
برای مثال، فرض کنید شما یک تگ inclusion می نویسید که همواره در یک context که حاوی متغیرهای  home_link و home_title می باشد استفاده خواهد شد که به صفحه ی اصلی اشاره می کند. تابع پایتون آن به شکل زیر خواهد بود:
[/p]

[code]
@register.inclusion_tag('link.html', takes_context=True)
def jump_link(context):
    return {
        'link': context['home_link'],
        'title': context['home_title'],
    }
[/code]

[p]id="232"[p/]
(توجه داشته باشید که اولین پارامتر باید context نامیده شود.)
[/p]

[p]id="233"[p/]
template مورد نظر یعنی link.html باید حاوی کد زیر باشد:
[/p]

[code]
Jump directly to <a href="{{ link }}">{{ title }}</a>.
[/code]

[p]id="234"[p/]
سپس، هر زمان که بخواهید از آن تگ سفارشی استفاده کنید، کتابخانه ی آن را بارگذاری کرده و آن را بدون هیچ آرگومانی فراخوانی کنید:
[/p]

[code]
{% jump_link %}
[/code]

[h3]id="235"«هس/»
نوشتن Template Loader های سفارشی
[/h3]

[p]id="236"[p/]
template loader های داخلی جنگو (که در بخش "داخل بارگذاری Template" توضیح داده شد) معمولا تمام احتیاجات بارگذاری template های شما را پوشش می دهند، ولی در صورتی که نیاز به منطق ویژه ی بارگذاری باشد، نوشتن Template loader برای خودتان واقعا ساده می باشد. برای مثال، می توان template ها را از یک پایگاه داده، یا به طور مستقیم از یک Subversion repository و یا (همانطور که کمی بعد توضیح داده خواهد شد) از یک ZIP archive بارگذاری کرد.
[/p]

[p]id="237"[p/]
انتظار می رود یک template loader (هر آیتم در تنظیم TEMPLATE_LOADERS می باشد) یک آبجکت قابل فراخوانی با رابط زیر باشد:
[/p]

[code]
load_template_source(template_name, template_dirs=None)
[/code]

[p]id="238"[p/]
آرگومان template_name نام template برای بارگذاری می باشد (همانطور که به loader.get_template() یا loader.select_template() ارسال شده است)،  و template_dirs یک لیست اختیاری از دیکشنری ها برای جستجو به جای TEMPLATE_DIRS است.
[/p]

[p]id="239"[p/]
در صورتیکه یک loader قادر به بارگذاری یک template به طور موفقیت آمیز باشد، باید یک تاپل بر گرداند: (template_source، template_path). در اینجا template_source رشته ی template ای است که از طریق موتور template کامپایل خواهد شد، و template_path مسیر template ای است که از آن بارگذاری شده است. این مسیر ممکن است برای اهداف اشکال زدایی برای نشان داده شود، بنابراین باید جایی که template از آن بارگذاری شده است را به سرعت شناسایی کند.
[/p]

[p]id="240"[p/]
در صورتیکه loader برای بارگذاری یک template ناتوان باشد، خطای django.template.TemplateDoesNotExist ایجاد خواهد شد.
[/p]

[p]id="241"[p/]
همچنین هر تابع loader باید یک attribute تابع is_usable داشته باشد. این attribute یک Boolean می باشد که به موتور template این موضوع را که آیا این loader در نصب پایتون فعلی در دسترس است یا خیر را اطلاع می دهد. برای مثال egg های loader (که قابلیت بارگذاری template ها از egg های پایتون را دارند) در صورتیکه ماژول pkg_resources نصب نشده باشد is_usable را False قرار می دهند، زیرا pkg_resource جهت خواندن داده از egg ها ضروری می باشد.
[/p]

[p]id="242"[p/]
یک مثال برای روشن کردن موضوع می تواند موثر باشد. در اینجا تابع template loader که می تواند template ها را از یک فایل ZIP بارگذاری کند وجود دارد. مثال زیر به جای TEMPLATE_DIRS به صورت یک مسیر جستجو، یک تنظیم سفارشی با نام TEMPLATE_ZIP_FILES را استفاده می کند، و انتظار دارد که هر آیتم در آن مسیر یک فایل ZIP حاوی template هایی باشد:
[/p]

[code]
from django.conf import settings
from django.template import TemplateDoesNotExist
import zipfile

def load_template_source(template_name, template_dirs=None):
    "Template loader that loads templates from a ZIP file."

    template_zipfiles = getattr(settings, "TEMPLATE_ZIP_FILES", [])

    # Try each ZIP file in TEMPLATE_ZIP_FILES.
    for fname in template_zipfiles:
        try:
            z = zipfile.ZipFile(fname)
            source = z.read(template_name)
        except (IOError, KeyError):
            continue
        z.close()
        # We found a template, so return the source.
        template_path = "%s:%s" % (fname, template_name)
        return (source, template_path)

    # If we reach here, the template couldn't be loaded
    raise TemplateDoesNotExist(template_name)

# This loader is always usable (since zipfile is included with Python)
load_template_source.is_usable = True
[/code]

[p]id="243"[p/]
تنها قدم کج در صورتیکه بخواهیم از این loader برای اضافه کردن آن به تنظیم TEMPLATE_LOADERS استفاده کنیم. در صورتیکه کد فوق را در یک پکیج به نام mysite.zip_loader قرار دهیم، سپس mysite.zip_loader.load_template_source را به TEMPLATE_LOADERS اضافه کنیم.
[/p]

[h3]id="244"«هس/»
پیکربندی Template System در حالت مستقل
[/h3]

[note]
نکته
[note/]

[p]id="245"[p/]
این بخش برای افرادی که در تلاش برای استفاده از template system به صورت یک جزء خروجی در برنامه ی دیگر هستند جالب است. در صورتیکه از template system به صورت بخشی از یک برنامه ی جنگو استفاده می کنید، اطلاعات ارائه شده در اینجا برای شما بکار نخواهد رفت.
[/p]
[/note]

[p]id="246"[p/]
به طور عادی، جنگو تمام اطلاعات پیکربندی ای مورد نیاز را از فایل پیکربندی پیشفرض خود بارگذاری می کند، ترکیب شده با تنظیمات داده شده در متغیر محیطی DJANGO_SETTINGS_MODULE. (این موضوع در فصل چهارم توضیح داده شده است.) ولی در صورتیکه template system را مستقل از باقی جنگو می خواهید استفاده کنید، روش متغیر محیطی خیلی مناسب نمی باشد، زیرا شاید بخواهید template system را با باقی برنامه ی خود به جای سر و کار داشتن با تنظیم فایل ها و اشاره به آن ها از طریق متغیر محیطی پیکربندی کنید.
[/p]

[p]id="247"[p/]
برای حل این مشکل، نیاز است امکان پیکربندی دستی را استفاده کنید. به طور خلاصه، نیاز است قسمت های مناسب template systm را import کرده و سپس، قبل از فراخوانی هر تابع template ای، django.conf.settings.configure() را با هر تنظیمی که می خواهید تعیین کنید فراخوانی کنید.
[/p]

[h3]id="248"«هس/»
گام بعدی
[/h3]

[p]id="249"[p/]
فصل بعدی کاربرد پیشرفته ی مدل جنگو را پوشش می دهد.
[/p]
